/// Auto-generated cross-language Gaussian tests.
/// Generated by scripts/src/10_cross_language_vectors.py - DO NOT EDIT.
module gaussian::cross_language_vectors;

use gaussian::normal_forward;
use gaussian::normal_inverse;
use gaussian::signed_wad;

const FNV_OFFSET_BASIS_128: u256 = 144066263297769815596495629667062367629;
const FNV_PRIME_128: u256 = 309485009821345068724781371;
const MOD_2_128: u256 = 340282366920938463463374607431768211456; // 2^128

const NUM_Z: u64 = 24;
const NUM_P: u64 = 24;
const CDF_TOLERANCE: u256 = 200000000000;
const PDF_TOLERANCE: u256 = 200000000000;
// Tighter tolerances (WAD): tails = 0.1, central = 0.02
const PPF_TOLERANCES: vector<u256> = vector[
    100_000_000_000_000_000, 100_000_000_000_000_000, 100_000_000_000_000_000,
    100_000_000_000_000_000, 100_000_000_000_000_000, 100_000_000_000_000_000,
    100_000_000_000_000_000, 100_000_000_000_000_000, 20_000_000_000_000_000, 20_000_000_000_000_000,
    20_000_000_000_000_000, 20_000_000_000_000_000, 20_000_000_000_000_000, 20_000_000_000_000_000,
    20_000_000_000_000_000, 20_000_000_000_000_000, 100_000_000_000_000_000, 100_000_000_000_000_000,
    100_000_000_000_000_000, 100_000_000_000_000_000, 100_000_000_000_000_000,
    100_000_000_000_000_000, 100_000_000_000_000_000, 100_000_000_000_000_000,
];
const CHECKSUM_MASK: u128 = 0xFFFFFFFFFFFFFFFF;
const PROB_CHECKSUM_LOW: u64 = 12618402257139963786;
const PPF_CHECKSUM_LOW: u64 = 10576390417509137969;
const Z_MAGNITUDES: vector<u256> = vector[
    5722604395144404000, 5256112156024795000, 4714140208008862000, 4230263197094064000,
    3790582265211235000, 3202437764836324300, 2723886029800964600, 2221393569472305000,
    1787188636732445400, 1254961406210443300, 762920197576741900, 207323501115139800,
    264386512008066450, 782276161327083000, 1244341419882733200, 1722723872178477700,
    2255458478701583700, 2706381725610417500, 3282763117199258400, 3763166439912206700,
    4275808774008538000, 4735452596812987000, 5297069802439490000, 5789312112132220000,
];
const Z_SIGNS: vector<bool> = vector[
    true, true, true, true, true, true, true, true, true, true, true, true, false, false, false,
    false, false, false, false, false, false, false, false, false,
];
const CDF_EXPECTED: vector<u256> = vector[
    5245167161, 73566291257, 1213667441608, 11670902296396, 75147271413601, 681348707087830,
    3225938331949917, 13162158100439613, 36953502639261296, 104746385265759580, 222755494971994150,
    417878610808379400, 604258948132041000, 782973853256021000, 893313033550637100,
    957530764394427100, 987947717155216100, 996598959624606800, 999486024973459100,
    999916112270562700, 999990477767861900, 999998907166058400, 999999941162139600,
    999999996466236800,
];
const PDF_EXPECTED: vector<u256> = vector[
    30883645504, 399802152257, 5959657865885, 51883907072567, 302570730535892, 2365555615601304,
    9767291428574637, 33835889224136946, 80785309359954370, 181517611170230350, 298208567263412900,
    390459881872392500, 385240044386933540, 293782221450510300, 183942638396345530,
    90461828381610960, 31351755778486964, 10242704780140267, 1823121066276091, 335580274993591,
    42747114191652, 5388765785552, 322097101579, 21036519221,
];
const PROB_INPUTS: vector<u128> = vector[
    51250954666046670, 113972138009695740, 172756856902451930, 227252071899905900,
    288001662849112200, 353735534453962550, 405052653045655700, 473212284183827600,
    532970694287520400, 589679349528437100, 648030324268193100, 707784256121007700,
    767548695876541200, 829450763058826500, 890045482589579400, 949900000000000000, 1000000000,
    271441761659, 73680629972808, 20000000000000000, 999999999000000000, 999999728558238400,
    999926319370027200, 980000000000000000,
];
const PPF_EXPECTED_MAG: vector<u256> = vector[
    1632843529798255500, 1205671246407477700, 943326913503980300, 747927077784661900,
    559232103964393500, 375254678228285950, 240290181510214560, 67197383142325410, 82739581306106410,
    226720222917264490, 380008168710889270, 546923212224820100, 730797897051183900,
    951997058085864500, 1226770038833579800, 1643884802230035000, 5997807010584733000,
    5010501581020661000, 3795474637775838400, 2053748910631822500, 5997807019601637500,
    5010501581060014000, 3795474637775838400, 2053748910631822500,
];
const PPF_EXPECTED_NEG: vector<bool> = vector[
    true, true, true, true, true, true, true, true, false, false, false, false, false, false, false,
    false, true, true, true, true, false, false, false, false,
];

fun fnv_update(acc: u256, value: u256): u256 {
    ((acc ^ value) * FNV_PRIME_128) % MOD_2_128
}

fun checksum_probs(): u128 {
    let mut acc: u256 = FNV_OFFSET_BASIS_128;
    let probs = PROB_INPUTS;
    let mut i = 0;
    while (i < NUM_P) {
        let p = *std::vector::borrow(&probs, i);
        acc = fnv_update(acc, (p as u256));
        i = i + 1;
    };
    acc = fnv_update(acc, (NUM_P as u256));
    (acc % MOD_2_128) as u128
}

fun checksum_ppf_vectors(): u128 {
    let mut acc: u256 = FNV_OFFSET_BASIS_128;
    let mags = PPF_EXPECTED_MAG;
    let negs = PPF_EXPECTED_NEG;
    let mut i = 0;
    while (i < NUM_P) {
        let mag = *std::vector::borrow(&mags, i);
        let neg = if (*std::vector::borrow(&negs, i)) { 1 } else { 0 };
        acc = fnv_update(acc, mag);
        acc = fnv_update(acc, neg);
        i = i + 1;
    };
    acc = fnv_update(acc, (NUM_P as u256));
    (acc % MOD_2_128) as u128
}

#[test]
fun test_crosslang_cdf_pdf() {
    let z_magnitudes = Z_MAGNITUDES;
    let z_signs = Z_SIGNS;
    let cdf_values = CDF_EXPECTED;
    let pdf_values = PDF_EXPECTED;
    let mut i = 0;
    while (i < NUM_Z) {
        let mag = *std::vector::borrow(&z_magnitudes, i);
        let neg = *std::vector::borrow(&z_signs, i);
        let z = signed_wad::new(mag as u256, neg);
        let cdf_expected = *std::vector::borrow(&cdf_values, i);
        let pdf_expected = *std::vector::borrow(&pdf_values, i);
        let actual_cdf = normal_forward::cdf_standard(&z);
        let actual_pdf = normal_forward::pdf_standard(&z);
        let cdf_diff = if (actual_cdf > cdf_expected) { actual_cdf - cdf_expected } else {
            cdf_expected - actual_cdf
        };
        let pdf_diff = if (actual_pdf > pdf_expected) { actual_pdf - pdf_expected } else {
            pdf_expected - actual_pdf
        };
        assert!(cdf_diff <= CDF_TOLERANCE, 0);
        assert!(pdf_diff <= PDF_TOLERANCE, 1);
        i = i + 1;
    };
}

#[test]
fun test_crosslang_ppf() {
    let prob_inputs = PROB_INPUTS;
    let mag_values = PPF_EXPECTED_MAG;
    let neg_values = PPF_EXPECTED_NEG;
    let tol_values = PPF_TOLERANCES;
    let mut i = 0;
    while (i < NUM_P) {
        let prob = *std::vector::borrow(&prob_inputs, i);
        let expected_mag = *std::vector::borrow(&mag_values, i);
        let expected_neg = *std::vector::borrow(&neg_values, i);
        let tolerance = *std::vector::borrow(&tol_values, i);
        let expected = signed_wad::new(expected_mag as u256, expected_neg);
        let actual = normal_inverse::ppf(prob);
        let actual_mag = signed_wad::abs(&actual);
        let expected_mag_u256 = signed_wad::abs(&expected);
        let diff = if (actual_mag > expected_mag_u256) { actual_mag - expected_mag_u256 } else {
            expected_mag_u256 - actual_mag
        };
        assert!(diff <= tolerance, 0);
        assert!(signed_wad::is_negative(&actual) == signed_wad::is_negative(&expected), 1);
        i = i + 1;
    };
}

#[test]
fun test_vector_checksums() {
    let prob_chk = checksum_probs();
    let prob_low = (prob_chk & CHECKSUM_MASK) as u64;
    assert!(prob_low == PROB_CHECKSUM_LOW, prob_low);
    let ppf_chk = checksum_ppf_vectors();
    let ppf_low = (ppf_chk & CHECKSUM_MASK) as u64;
    assert!(ppf_low == PPF_CHECKSUM_LOW, ppf_low);
}
