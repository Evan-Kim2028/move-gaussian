/// Boundary Exploitation Test Suite for move-gaussian
/// 
/// This module contains tests targeting edge cases and boundary conditions
/// that could potentially be exploited for precision attacks or unexpected behavior.
/// 
/// # Categories
/// 
/// 1. **Domain Boundary Tests** - EPS, MAX_Z, P_LOW, P_HIGH boundaries
/// 2. **Precision Attack Tests** - Numerical precision edge cases
/// 3. **Type Boundary Tests** - u64, u128, u256 limits
/// 4. **Arithmetic Edge Cases** - Near-zero, near-overflow scenarios
/// 
/// # Usage
/// 
/// ```bash
/// sui move test --filter boundary_exploit
/// ```
#[test_only]
module gaussian::boundary_exploit {
    use gaussian::coefficients;
    use gaussian::math;
    use gaussian::normal_forward;
    use gaussian::normal_inverse;
    use gaussian::sampling;
    use gaussian::signed_wad;
    use gaussian::erf;
    use gaussian::transcendental;

    // === Constants ===
    
    const SCALE: u256 = 1_000_000_000_000_000_000;
    const SCALE_U128: u128 = 1_000_000_000_000_000_000;
    
    const EPS: u128 = 100_000_000;
    const MAX_Z: u256 = 6_000_000_000_000_000_000;
    const P_LOW: u128 = 20_000_000_000_000_000;
    const P_HIGH: u128 = 980_000_000_000_000_000;

    // ============================================
    // DOMAIN BOUNDARY TESTS - EPS
    // ============================================
    
    /// Test PPF exactly at EPS boundary.
    /// 
    /// Exploit attempt: Find undefined behavior at minimum probability.
    #[test]
    fun test_ppf_at_eps() {
        let z = normal_inverse::ppf(EPS);
        
        // Should return large negative z
        assert!(signed_wad::is_negative(&z), 0);
        
        let z_mag = signed_wad::abs(&z);
        // z should be around -6.36 for p = 1e-10
        assert!(z_mag > 6 * SCALE, 1);
        assert!(z_mag < 7 * SCALE, 2);
    }
    
    /// Test PPF below EPS (should clamp).
    /// 
    /// Exploit attempt: Cause underflow or undefined behavior with p < EPS.
    #[test]
    fun test_ppf_below_eps_clamps() {
        let z_at_eps = normal_inverse::ppf(EPS);
        
        // Values below EPS should clamp to EPS
        let z_below = normal_inverse::ppf(1);
        let z_way_below = normal_inverse::ppf(0); // This might be special-cased
        
        // All should give approximately the same result
        let z_eps_mag = signed_wad::abs(&z_at_eps);
        let z_below_mag = signed_wad::abs(&z_below);
        
        // Should be clamped to same value
        assert!(z_eps_mag == z_below_mag, 0);
    }
    
    /// Test PPF at (1 - EPS) boundary.
    /// 
    /// Exploit attempt: Find undefined behavior at maximum probability.
    #[test]
    fun test_ppf_at_one_minus_eps() {
        let p = SCALE_U128 - EPS;
        let z = normal_inverse::ppf(p);
        
        // Should return large positive z
        assert!(!signed_wad::is_negative(&z), 0);
        
        let z_mag = signed_wad::abs(&z);
        assert!(z_mag > 6 * SCALE, 1);
        assert!(z_mag < 7 * SCALE, 2);
    }
    
    /// Test PPF above (1 - EPS) (should clamp).
    /// 
    /// Exploit attempt: Cause overflow with p > 1 - EPS.
    #[test]
    fun test_ppf_above_one_minus_eps_clamps() {
        let z_at_boundary = normal_inverse::ppf(SCALE_U128 - EPS);
        
        // Values above should clamp
        let z_above = normal_inverse::ppf(SCALE_U128 - 1);
        
        let z_boundary_mag = signed_wad::abs(&z_at_boundary);
        let z_above_mag = signed_wad::abs(&z_above);
        
        // Should be clamped to same value
        assert!(z_boundary_mag == z_above_mag, 0);
    }

    // ============================================
    // DOMAIN BOUNDARY TESTS - MAX_Z
    // ============================================
    
    /// Test CDF at MAX_Z boundary.
    /// 
    /// Exploit attempt: Find discontinuity at domain edge.
    #[test]
    fun test_cdf_at_max_z() {
        let z = signed_wad::from_wad(MAX_Z);
        let cdf = normal_forward::cdf_standard(&z);
        
        // CDF(6) should be very close to 1.0
        assert!(cdf > SCALE - SCALE / 100, 0); // > 0.99
        assert!(cdf <= SCALE, 1);
    }
    
    /// Test CDF beyond MAX_Z (should clamp).
    /// 
    /// Exploit attempt: Cause undefined behavior with |z| > 6.
    #[test]
    fun test_cdf_beyond_max_z_clamps() {
        let z_at_max = signed_wad::from_wad(MAX_Z);
        let z_beyond = signed_wad::from_wad(10 * SCALE); // z = 10
        
        let cdf_at_max = normal_forward::cdf_standard(&z_at_max);
        let cdf_beyond = normal_forward::cdf_standard(&z_beyond);
        
        // Should be clamped to essentially the same value
        let diff = if (cdf_beyond > cdf_at_max) {
            cdf_beyond - cdf_at_max
        } else {
            cdf_at_max - cdf_beyond
        };
        
        // Difference should be negligible
        assert!(diff < SCALE / 10000, 0);
    }
    
    /// Test CDF at negative MAX_Z boundary.
    /// 
    /// Exploit attempt: Find asymmetry at negative domain edge.
    #[test]
    fun test_cdf_at_negative_max_z() {
        let z = signed_wad::new(MAX_Z, true); // -6.0
        let cdf = normal_forward::cdf_standard(&z);
        
        // CDF(-6) should be very close to 0.0
        assert!(cdf < SCALE / 100, 0); // < 0.01
        assert!(cdf >= 0, 1);
    }
    
    /// Test PDF at MAX_Z (should be nearly zero).
    /// 
    /// Exploit attempt: Find non-zero PDF in extreme tail.
    #[test]
    fun test_pdf_at_max_z() {
        let z = signed_wad::from_wad(MAX_Z);
        let pdf = normal_forward::pdf_standard(&z);
        
        // PDF(6) should be extremely small
        assert!(pdf < SCALE / 1000000, 0); // < 1e-6
    }
    
    /// Test PDF beyond MAX_Z (should be zero).
    #[test]
    fun test_pdf_beyond_max_z_is_zero() {
        let z = signed_wad::from_wad(10 * SCALE); // z = 10
        let pdf = normal_forward::pdf_standard(&z);
        
        // Should be exactly or nearly zero
        assert!(pdf == 0, 0);
    }

    // ============================================
    // DOMAIN BOUNDARY TESTS - ZERO
    // ============================================
    
    /// Test PDF at zero is maximum.
    /// 
    /// Exploit attempt: Verify PDF(0) = 1/√(2π) exactly.
    #[test]
    fun test_pdf_at_zero_is_maximum() {
        let z = signed_wad::zero();
        let pdf_zero = normal_forward::pdf_standard(&z);
        
        // PDF should be maximum at z = 0
        let z_small = signed_wad::from_wad(SCALE / 10); // z = 0.1
        let pdf_small = normal_forward::pdf_standard(&z_small);
        
        assert!(pdf_zero > pdf_small, 0);
        
        // PDF(0) = 1/√(2π) ≈ 0.3989
        let expected = 398_942_280_401_432_700;
        let tolerance = SCALE / 10000;
        let diff = if (pdf_zero > expected) { 
            pdf_zero - expected 
        } else { 
            expected - pdf_zero 
        };
        assert!(diff < tolerance, 1);
    }
    
    /// Test CDF at zero is exactly 0.5.
    /// 
    /// Exploit attempt: Find bias in CDF(0).
    #[test]
    fun test_cdf_at_zero_is_half() {
        let z = signed_wad::zero();
        let cdf = normal_forward::cdf_standard(&z);
        
        let expected = SCALE / 2;
        let tolerance = SCALE / 1000; // 0.1%
        
        let diff = if (cdf > expected) { 
            cdf - expected 
        } else { 
            expected - cdf 
        };
        
        assert!(diff < tolerance, 0);
    }
    
    /// Test PPF at 0.5 is zero.
    /// 
    /// Exploit attempt: Find bias in PPF(0.5).
    #[test]
    fun test_ppf_at_half_is_zero() {
        let p = SCALE_U128 / 2; // 0.5
        let z = normal_inverse::ppf(p);
        
        let z_mag = signed_wad::abs(&z);
        let tolerance = SCALE / 10; // 0.1
        
        assert!(z_mag < tolerance, 0);
    }

    // ============================================
    // PRECISION ATTACK TESTS
    // ============================================
    
    /// Test mul_div precision at SCALE boundary.
    /// 
    /// Exploit attempt: Find precision loss when multiplying scaled values.
    #[test]
    fun test_mul_div_no_precision_loss_at_scale() {
        // 1.0 * 1.0 should equal 1.0 exactly
        let result = math::mul_div(SCALE, SCALE);
        assert!(result == SCALE, 0);
        
        // 2.0 * 0.5 should equal 1.0 exactly
        let result2 = math::mul_div(2 * SCALE, SCALE / 2);
        assert!(result2 == SCALE, 1);
        
        // 1.5 * 2.0 should equal 3.0 exactly
        let result3 = math::mul_div(3 * SCALE / 2, 2 * SCALE);
        assert!(result3 == 3 * SCALE, 2);
    }
    
    /// Test div_scaled precision with small denominators.
    /// 
    /// Exploit attempt: Cause precision loss with small divisors.
    #[test]
    fun test_div_scaled_small_denominator() {
        // 1.0 / 0.001 = 1000.0
        let result = math::div_scaled(SCALE, SCALE / 1000);
        let expected = 1000 * SCALE;
        
        // Should be exact or very close
        let diff = if (result > expected) { 
            result - expected 
        } else { 
            expected - result 
        };
        
        assert!(diff < SCALE / 1000, 0); // < 0.1% error
    }
    
    /// Test div_scaled with very small denominator.
    /// 
    /// Exploit attempt: Find overflow or precision issues.
    #[test]
    fun test_div_scaled_tiny_denominator() {
        // 1.0 / 0.000001 = 1,000,000.0
        let result = math::div_scaled(SCALE, SCALE / 1000000);
        let expected = 1000000 * SCALE;
        
        // Should be close (some precision loss acceptable)
        let diff = if (result > expected) { 
            result - expected 
        } else { 
            expected - result 
        };
        
        // Allow up to 1% error for very small denominators
        assert!(diff < expected / 100, 0);
    }
    
    /// Test signed arithmetic near-cancellation.
    /// 
    /// Exploit attempt: Find precision loss when subtracting similar values.
    #[test]
    fun test_signed_add_near_cancellation() {
        let a = signed_wad::from_wad(SCALE); // 1.0
        let b = signed_wad::new(SCALE - 1, true); // -0.999999...
        
        let result = signed_wad::add(&a, &b);
        
        // Result should be very small positive
        assert!(!signed_wad::is_negative(&result), 0);
        
        let result_mag = signed_wad::abs(&result);
        assert!(result_mag == 1, 1); // Should be exactly 1
    }
    
    /// Test signed arithmetic exact cancellation.
    /// 
    /// Exploit attempt: Verify exact zero on cancellation.
    #[test]
    fun test_signed_add_exact_cancellation() {
        let a = signed_wad::from_wad(SCALE);
        let b = signed_wad::new(SCALE, true);
        
        let result = signed_wad::add(&a, &b);
        
        assert!(signed_wad::is_zero(&result), 0);
        assert!(!signed_wad::is_negative(&result), 1); // Zero should not be negative
    }
    
    /// Test multiplication precision with large values.
    /// 
    /// Exploit attempt: Find overflow in intermediate calculations.
    #[test]
    fun test_mul_div_large_values() {
        // Large but safe values
        let a = 1000 * SCALE; // 1000.0
        let b = 1000 * SCALE; // 1000.0
        
        let result = math::mul_div(a, b);
        let expected = 1000000 * SCALE; // 1,000,000.0
        
        assert!(result == expected, 0);
    }

    // ============================================
    // ERF BOUNDARY TESTS
    // ============================================
    
    /// Test erf at zero.
    /// 
    /// Exploit attempt: Verify erf(0) = 0 exactly.
    #[test]
    fun test_erf_at_zero() {
        let result = erf::erf(0);
        assert!(result == 0, 0);
    }
    
    /// Test erfc at zero.
    /// 
    /// Exploit attempt: Verify erfc(0) = 1 exactly.
    #[test]
    fun test_erfc_at_zero() {
        let result = erf::erfc(0);
        assert!(result == SCALE, 0);
    }
    
    /// Test erf at MAX_INPUT (6.0).
    /// 
    /// Exploit attempt: Find discontinuity at domain edge.
    #[test]
    fun test_erf_at_max_input() {
        let result = erf::erf(6 * SCALE);
        
        // erf(6) should be essentially 1.0
        assert!(result > SCALE - SCALE / 1000000, 0);
        assert!(result <= SCALE, 1);
    }
    
    /// Test erf beyond MAX_INPUT (clamped).
    /// 
    /// Exploit attempt: Cause undefined behavior with x > 6.
    #[test]
    fun test_erf_beyond_max_input_clamps() {
        let erf_at_6 = erf::erf(6 * SCALE);
        let erf_at_10 = erf::erf(10 * SCALE);
        
        // Should be clamped to same value
        assert!(erf_at_6 == erf_at_10, 0);
    }
    
    /// Test erf_strict fails beyond domain.
    /// 
    /// Exploit attempt: Verify strict mode rejects out-of-domain inputs.
    #[test]
    #[expected_failure(abort_code = 101)]
    fun test_erf_strict_beyond_max_aborts() {
        let _result = erf::erf_strict(10 * SCALE);
    }

    // ============================================
    // TRANSCENDENTAL BOUNDARY TESTS
    // ============================================
    
    /// Test ln at 1.0 (should be zero).
    /// 
    /// Exploit attempt: Verify ln(1) = 0 exactly.
    #[test]
    fun test_ln_at_one() {
        let result = transcendental::ln_wad(SCALE);
        assert!(signed_wad::is_zero(&result), 0);
    }
    
    /// Test ln at very small value.
    /// 
    /// Exploit attempt: Find precision loss near zero.
    #[test]
    fun test_ln_at_small_value() {
        // ln(0.001) ≈ -6.9078
        let result = transcendental::ln_wad(SCALE / 1000);
        
        assert!(signed_wad::is_negative(&result), 0);
        
        let result_mag = signed_wad::abs(&result);
        let expected = 6_907_755_278_982_137_052; // ln(1000) ≈ 6.9078
        let tolerance = expected / 100; // 1%
        
        let diff = if (result_mag > expected) { 
            result_mag - expected 
        } else { 
            expected - result_mag 
        };
        
        assert!(diff < tolerance, 1);
    }
    
    /// Test ln at large value.
    /// 
    /// Exploit attempt: Find overflow at large inputs.
    #[test]
    fun test_ln_at_large_value() {
        // ln(1000000) ≈ 13.8155
        let result = transcendental::ln_wad(1000000 * SCALE);
        
        assert!(!signed_wad::is_negative(&result), 0);
        
        let result_mag = signed_wad::abs(&result);
        let expected = 13_815_510_557_964_274_104; // ln(1000000)
        let tolerance = expected / 50; // 2%
        
        let diff = if (result_mag > expected) { 
            result_mag - expected 
        } else { 
            expected - result_mag 
        };
        
        assert!(diff < tolerance, 1);
    }
    
    /// Test sqrt at perfect squares.
    /// 
    /// Exploit attempt: Verify exact results for perfect squares.
    #[test]
    fun test_sqrt_perfect_squares() {
        // sqrt(1) = 1
        let sqrt_1 = transcendental::sqrt_wad(SCALE);
        let diff_1 = if (sqrt_1 > SCALE) { sqrt_1 - SCALE } else { SCALE - sqrt_1 };
        assert!(diff_1 < 1000, 0); // Essentially exact
        
        // sqrt(4) = 2
        let sqrt_4 = transcendental::sqrt_wad(4 * SCALE);
        let expected_2 = 2 * SCALE;
        let diff_2 = if (sqrt_4 > expected_2) { sqrt_4 - expected_2 } else { expected_2 - sqrt_4 };
        assert!(diff_2 < 1000, 1);
        
        // sqrt(9) = 3
        let sqrt_9 = transcendental::sqrt_wad(9 * SCALE);
        let expected_3 = 3 * SCALE;
        let diff_3 = if (sqrt_9 > expected_3) { sqrt_9 - expected_3 } else { expected_3 - sqrt_9 };
        assert!(diff_3 < 1000, 2);
    }
    
    /// Test sqrt at zero.
    /// 
    /// Exploit attempt: Verify sqrt(0) = 0 exactly.
    #[test]
    fun test_sqrt_at_zero() {
        let result = transcendental::sqrt_wad(0);
        assert!(result == 0, 0);
    }
    
    /// Test sqrt at very small value.
    /// 
    /// Exploit attempt: Find precision loss near zero.
    #[test]
    fun test_sqrt_at_small_value() {
        // sqrt(0.0001) = 0.01
        let result = transcendental::sqrt_wad(SCALE / 10000);
        let expected = SCALE / 100;
        
        let diff = if (result > expected) { 
            result - expected 
        } else { 
            expected - result 
        };
        
        // Allow small error for very small values
        assert!(diff < expected / 100, 0);
    }

    // ============================================
    // UNIFORM SAMPLING BOUNDARY TESTS
    // ============================================
    
    /// Test uniform conversion at u64 boundaries.
    /// 
    /// Exploit attempt: Find edge cases in u64 → WAD conversion.
    #[test]
    fun test_uniform_from_u64_boundaries() {
        // Minimum: 0 should give 0
        let u_min = sampling::uniform_from_u64(0);
        assert!(u_min == 0, 0);
        
        // Maximum: u64::MAX should give close to SCALE
        let u_max = sampling::uniform_from_u64(0xFFFFFFFFFFFFFFFF);
        // Should be just under SCALE (since it's [0, 1))
        assert!(u_max < SCALE, 1);
        assert!(u_max > SCALE - SCALE / 1000, 2); // Should be > 0.999
    }
    
    /// Test open interval mapping.
    /// 
    /// Exploit attempt: Verify endpoints are properly excluded.
    #[test]
    fun test_uniform_open_interval_boundaries() {
        // At 0, should get EPS (not 0)
        let p_at_zero = sampling::uniform_open_interval_from_u64(0);
        assert!(p_at_zero >= EPS, 0);
        
        // At max, should get close to SCALE - EPS (not SCALE)
        let p_at_max = sampling::uniform_open_interval_from_u64(0xFFFFFFFFFFFFFFFF);
        assert!(p_at_max <= SCALE_U128 - EPS, 1);
        
        // Should be strictly ordered
        assert!(p_at_zero < p_at_max, 2);
    }

    // ============================================
    // CLT BOUNDARY TESTS
    // ============================================
    
    /// Test CLT with all-zero uniforms.
    /// 
    /// Exploit attempt: Find extreme case behavior.
    #[test]
    fun test_clt_all_zeros() {
        let mut uniforms = std::vector::empty<u256>();
        let mut i: u64 = 0;
        while (i < 12) {
            std::vector::push_back(&mut uniforms, 0);
            i = i + 1;
        };
        
        let (z_mag, z_neg) = sampling::clt_from_uniforms(&uniforms);
        
        // Sum = 0, mean = 6, so z = 0 - 6 = -6
        assert!(z_neg == true, 0);
        assert!(z_mag == 6 * SCALE, 1);
    }
    
    /// Test CLT with all-max uniforms.
    /// 
    /// Exploit attempt: Find extreme case behavior.
    #[test]
    fun test_clt_all_max() {
        let mut uniforms = std::vector::empty<u256>();
        let mut i: u64 = 0;
        while (i < 12) {
            std::vector::push_back(&mut uniforms, SCALE);
            i = i + 1;
        };
        
        let (z_mag, z_neg) = sampling::clt_from_uniforms(&uniforms);
        
        // Sum = 12, mean = 6, so z = 12 - 6 = 6
        assert!(z_neg == false, 0);
        assert!(z_mag == 6 * SCALE, 1);
    }
    
    /// Test CLT with wrong number of uniforms.
    /// 
    /// Exploit attempt: Cause undefined behavior with wrong input length.
    #[test]
    #[expected_failure(abort_code = 403)]
    fun test_clt_wrong_length_aborts() {
        let mut uniforms = std::vector::empty<u256>();
        let mut i: u64 = 0;
        while (i < 10) { // Wrong: should be 12
            std::vector::push_back(&mut uniforms, SCALE / 2);
            i = i + 1;
        };
        
        let (_z_mag, _z_neg) = sampling::clt_from_uniforms(&uniforms);
    }

    // ============================================
    // SIGNED WAD EDGE CASES
    // ============================================
    
    /// Test SignedWad comparison edge cases.
    /// 
    /// Exploit attempt: Find comparison bugs at boundaries.
    #[test]
    fun test_signed_wad_comparison_edge_cases() {
        let zero = signed_wad::zero();
        let pos_small = signed_wad::from_wad(1);
        let neg_small = signed_wad::new(1, true);
        let pos_large = signed_wad::from_wad(SCALE);
        let neg_large = signed_wad::new(SCALE, true);
        
        // Zero comparisons
        assert!(signed_wad::eq(&zero, &zero), 0);
        assert!(signed_wad::lt(&neg_small, &zero), 1);
        assert!(signed_wad::gt(&pos_small, &zero), 2);
        
        // Cross-sign comparisons
        assert!(signed_wad::lt(&neg_large, &pos_small), 3);
        assert!(signed_wad::gt(&pos_small, &neg_large), 4);
        
        // Same-sign magnitude comparisons
        assert!(signed_wad::lt(&pos_small, &pos_large), 5);
        assert!(signed_wad::lt(&neg_large, &neg_small), 6); // -1.0 < -0.000...001
    }
    
    /// Test SignedWad division edge cases.
    /// 
    /// Exploit attempt: Find division bugs.
    #[test]
    fun test_signed_wad_division_edge_cases() {
        let one = signed_wad::from_wad(SCALE);
        let two = signed_wad::from_wad(2 * SCALE);
        
        // 1 / 2 = 0.5
        let half = signed_wad::div_wad(&one, &two);
        let half_mag = signed_wad::abs(&half);
        assert!(half_mag == SCALE / 2, 0);
        assert!(!signed_wad::is_negative(&half), 1);
        
        // -1 / 2 = -0.5
        let neg_one = signed_wad::new(SCALE, true);
        let neg_half = signed_wad::div_wad(&neg_one, &two);
        let neg_half_mag = signed_wad::abs(&neg_half);
        assert!(neg_half_mag == SCALE / 2, 2);
        assert!(signed_wad::is_negative(&neg_half), 3);
    }
    
    /// Test SignedWad division by zero aborts.
    /// 
    /// Exploit attempt: Cause division by zero.
    #[test]
    #[expected_failure(abort_code = 10)]
    fun test_signed_wad_division_by_zero_aborts() {
        let one = signed_wad::from_wad(SCALE);
        let zero = signed_wad::zero();
        
        let _result = signed_wad::div_wad(&one, &zero);
    }
}
