/// Auto-generated integration tests for sampling pipeline.
/// Generated by scripts/src/10_cross_language_vectors.py - DO NOT EDIT.
module gaussian::sampling_integration {
    use gaussian::sampling;
    use gaussian::signed_wad;

    const FNV_OFFSET_BASIS_128: u256 = 144066263297769815596495629667062367629;
    const FNV_PRIME_128: u256 = 309485009821345068724781371;
    const MOD_2_128: u256 = 340282366920938463463374607431768211456; // 2^128

    const MEAN: u256 = 500000000000000000;
    const STD_DEV: u256 = 1500000000000000000;
    const TOLERANCE: u256 = 50000000000;
    const NUM_SAMPLES: u64 = 12;
    const RAW_SEEDS: vector<u64> = vector[9334618346840842905, 10424100709723369767, 9443182695686696458, 17933673198744876582, 11342960890024317363, 10482980246973705466, 5290281280504745347, 10228930864023155047, 8624286824275906926, 11253583944051605563, 17163634629999896190, 4535784743480959579,];
    const Z_MAGS: vector<u256> = vector[15117235107641002, 163891274124802620, 29873324118984607, 1913944434959197400, 292121516417100300, 172005755456868860, 562796526532284100, 137067939871446830, 81496571805477260, 279470226379301250, 1479094706384868500, 687495131945207100,];
    const Z_NEG: vector<bool> = vector[false, false, false, false, false, false, true, false, true, false, false, true,];
    const N_MAGS: vector<u256> = vector[522675852661461503, 745836911187203930, 544809986178476910, 3370916652438796100, 938182274625650450, 758008633185303290, 344194789798426150, 705601909807170245, 377755142291784110, 919205339568951875, 2718642059577302750, 531242697917810650,];
    const N_NEG: vector<bool> = vector[false, false, false, false, false, false, true, false, false, false, false, true,];
    const CHECKSUM_MASK: u128 = 0xFFFFFFFFFFFFFFFF;
    const SEED_CHECKSUM_LOW: u64 = 17598371369742458542;
    const Z_CHECKSUM_LOW: u64 = 4618213729539978121;
    const N_CHECKSUM_LOW: u64 = 4083440480162230076;
    fun fnv_update(acc: u256, value: u256): u256 {
        ((acc ^ value) * FNV_PRIME_128) % MOD_2_128
    }

    fun checksum_seeds(): u128 {
        let mut acc: u256 = FNV_OFFSET_BASIS_128;
        let seeds = RAW_SEEDS;
        let mut i = 0;
        while (i < NUM_SAMPLES) {
            let v = *std::vector::borrow(&seeds, i);
            acc = fnv_update(acc, (v as u256));
            i = i + 1;
        };
        acc = fnv_update(acc, (NUM_SAMPLES as u256));
        (acc % MOD_2_128) as u128
    }

    fun checksum_signed_vectors(mags: &vector<u256>, negs: &vector<bool>): u128 {
        let mut acc: u256 = FNV_OFFSET_BASIS_128;
        let len = std::vector::length(mags);
        let mut i = 0;
        while (i < len) {
            let mag = *std::vector::borrow(mags, i);
            let neg = if (*std::vector::borrow(negs, i)) { 1 } else { 0 };
            acc = fnv_update(acc, mag);
            acc = fnv_update(acc, neg);
            i = i + 1;
        };
        acc = fnv_update(acc, (len as u256));
        (acc % MOD_2_128) as u128
    }

    #[test]
    fun test_sample_z_from_seed() {
        let seeds = RAW_SEEDS;
        let mags = Z_MAGS;
        let signs = Z_NEG;
        let mut i = 0;
        while (i < NUM_SAMPLES) {
            let raw = *std::vector::borrow(&seeds, i);
            let expected_mag = *std::vector::borrow(&mags, i);
            let expected_neg = *std::vector::borrow(&signs, i);
            let expected = signed_wad::new(expected_mag, expected_neg);
            let actual = sampling::sample_z_from_u64(raw);
            let diff = signed_wad::abs(&signed_wad::sub(&actual, &expected));
            assert!(diff <= TOLERANCE, 0);
            assert!(signed_wad::is_negative(&actual) == signed_wad::is_negative(&expected), 1);
            i = i + 1;
        };
    }

    #[test]
    fun test_sample_normal_from_seed() {
        let seeds = RAW_SEEDS;
        let mags = N_MAGS;
        let signs = N_NEG;
        let mut i = 0;
        while (i < NUM_SAMPLES) {
            let raw = *std::vector::borrow(&seeds, i);
            let expected_mag = *std::vector::borrow(&mags, i);
            let expected_neg = *std::vector::borrow(&signs, i);
            let expected = signed_wad::new(expected_mag, expected_neg);
            let actual = sampling::sample_normal_from_u64(raw, MEAN, STD_DEV);
            let diff = signed_wad::abs(&signed_wad::sub(&actual, &expected));
            assert!(diff <= TOLERANCE, 0);
            assert!(signed_wad::is_negative(&actual) == signed_wad::is_negative(&expected), 1);
            i = i + 1;
        };
    }

    #[test]
    #[expected_failure(abort_code = sampling::EInvalidStdDev)]
    fun test_sample_normal_invalid_stddev() {
        let raw = 9334618346840842905;
        let _ = sampling::sample_normal_from_u64(raw, MEAN, 0, );
    }

    #[test]
    fun test_vector_checksums() {
        let seed_chk = checksum_seeds();
        let seed_low = (seed_chk & CHECKSUM_MASK) as u64;
        assert!(seed_low == SEED_CHECKSUM_LOW, seed_low);

        let z_mags = Z_MAGS;
        let z_neg = Z_NEG;
        let z_chk = checksum_signed_vectors(&z_mags, &z_neg);
        let z_low = (z_chk & CHECKSUM_MASK) as u64;
        assert!(z_low == Z_CHECKSUM_LOW, z_low);

        let n_mags = N_MAGS;
        let n_neg = N_NEG;
        let n_chk = checksum_signed_vectors(&n_mags, &n_neg);
        let n_low = (n_chk & CHECKSUM_MASK) as u64;
        assert!(n_low == N_CHECKSUM_LOW, n_low);
    }
}
