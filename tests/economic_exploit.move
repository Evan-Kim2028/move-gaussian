/// Economic Exploitation Test Suite for move-gaussian
/// 
/// This module contains tests simulating DeFi integration attacks where
/// mathematical precision errors could be exploited for economic gain.
/// 
/// # Attack Scenarios
/// 
/// 1. **Options Pricing Arbitrage** - Exploit CDF/PPF errors for mispricing
/// 2. **VaR Calculation Manipulation** - Underestimate risk using tail bias
/// 3. **Probability Boundary Exploitation** - Game probability thresholds
/// 4. **Roundtrip Error Accumulation** - Compound errors over many operations
/// 
/// # Usage
/// 
/// ```bash
/// sui move test --filter economic_exploit
/// ```
#[test_only]
module gaussian::economic_exploit {
    use gaussian::math;
    use gaussian::normal_forward;
    use gaussian::normal_inverse;
    use gaussian::signed_wad;
    use gaussian::transcendental;

    // === Constants ===
    
    const SCALE: u256 = 1_000_000_000_000_000_000;
    
    /// Maximum acceptable error for financial applications (0.05% = 5 basis points)
    const MAX_ERROR_BPS: u256 = 5;
    
    /// 1 basis point = 0.01% = SCALE / 10000
    const ONE_BPS: u256 = 100_000_000_000_000;

    // ============================================
    // OPTIONS PRICING ATTACK SIMULATION
    // ============================================
    
    /// Test that CDF errors are bounded for options pricing.
    /// 
    /// Attack scenario: In Black-Scholes, the option price depends on N(d1) and N(d2).
    /// If CDF has systematic bias, an attacker could exploit mispriced options.
    /// 
    /// Expected: CDF error < 0.05% at all critical points.
    #[test]
    fun test_cdf_error_bounded_for_options() {
        // Test at critical d-values commonly seen in options pricing
        // d1, d2 typically range from -3 to +3 for ATM/near-the-money options
        
        // Test point 1: N(0) = 0.5
        let z0 = signed_wad::from_wad(0);
        let cdf0 = normal_forward::cdf_standard(&z0);
        let expected0: u256 = 500_000_000_000_000_000;
        let diff0 = if (cdf0 > expected0) { cdf0 - expected0 } else { expected0 - cdf0 };
        let max_error0 = expected0 * MAX_ERROR_BPS / 10000;
        assert!(diff0 < max_error0 + ONE_BPS, 0);
        
        // Test point 2: N(1) ≈ 0.8413
        let z1 = signed_wad::from_wad(1_000_000_000_000_000_000);
        let cdf1 = normal_forward::cdf_standard(&z1);
        let expected1: u256 = 841_344_746_068_543_000;
        let diff1 = if (cdf1 > expected1) { cdf1 - expected1 } else { expected1 - cdf1 };
        let max_error1 = expected1 * MAX_ERROR_BPS / 10000;
        assert!(diff1 < max_error1 + ONE_BPS, 1);
        
        // Test point 3: N(2) ≈ 0.9772
        let z2 = signed_wad::from_wad(2_000_000_000_000_000_000);
        let cdf2 = normal_forward::cdf_standard(&z2);
        let expected2: u256 = 977_249_868_051_821_000;
        let diff2 = if (cdf2 > expected2) { cdf2 - expected2 } else { expected2 - cdf2 };
        let max_error2 = expected2 * MAX_ERROR_BPS / 10000;
        assert!(diff2 < max_error2 + ONE_BPS, 2);
    }
    
    /// Test that negative z-values have symmetric CDF errors.
    /// 
    /// Attack scenario: Asymmetric errors would allow put-call parity arbitrage.
    /// 
    /// Expected: Error at -z equals error at +z.
    #[test]
    fun test_cdf_error_symmetric() {
        let test_zs: vector<u256> = vector[
            500_000_000_000_000_000,   // 0.5
            1_000_000_000_000_000_000, // 1.0
            1_500_000_000_000_000_000, // 1.5
            2_000_000_000_000_000_000  // 2.0
        ];
        
        let mut i = 0;
        while (i < std::vector::length(&test_zs)) {
            let z_wad = *std::vector::borrow(&test_zs, i);
            
            let z_pos = signed_wad::from_wad(z_wad);
            let z_neg = signed_wad::new(z_wad, true);
            
            let cdf_pos = normal_forward::cdf_standard(&z_pos);
            let cdf_neg = normal_forward::cdf_standard(&z_neg);
            
            // CDF(-z) + CDF(z) should equal 1.0 exactly
            let sum = cdf_pos + cdf_neg;
            let diff_from_one = if (sum > SCALE) { sum - SCALE } else { SCALE - sum };
            
            // Symmetry error should be < 0.01% (1 bps)
            assert!(diff_from_one < ONE_BPS, i as u64);
            
            i = i + 1;
        };
    }
    
    /// Test PPF-CDF roundtrip error is bounded.
    /// 
    /// Attack scenario: If PPF(CDF(z)) ≠ z, an attacker could exploit
    /// the difference in hedging calculations.
    /// 
    /// Expected: Roundtrip error < 0.05% (5 bps).
    #[test]
    fun test_ppf_cdf_roundtrip_error_bounded() {
        let test_zs: vector<u256> = vector[
            0,
            500_000_000_000_000_000,   // 0.5
            1_000_000_000_000_000_000, // 1.0
            1_500_000_000_000_000_000, // 1.5
            2_000_000_000_000_000_000, // 2.0
            2_500_000_000_000_000_000  // 2.5
        ];
        
        let mut i = 0;
        while (i < std::vector::length(&test_zs)) {
            let z_wad = *std::vector::borrow(&test_zs, i);
            let z_orig = signed_wad::from_wad(z_wad);
            
            // Forward: z -> p
            let p = normal_forward::cdf_standard(&z_orig);
            
            // Inverse: p -> z_recovered
            let z_recovered = normal_inverse::ppf((p as u128));
            
            // Calculate roundtrip error
            let diff = signed_wad::abs(&signed_wad::sub(&z_orig, &z_recovered));
            
            // Error should be < 0.05% of z (or 0.01 WAD for small z)
            let z_mag = signed_wad::abs(&z_orig);
            let max_error = if (z_mag > 0) {
                z_mag * MAX_ERROR_BPS / 10000
            } else {
                SCALE / 100 // 0.01 for z=0
            };
            
            assert!(diff < max_error + SCALE / 100, i as u64);
            
            i = i + 1;
        };
    }

    // ============================================
    // VAR CALCULATION ATTACK SIMULATION
    // ============================================
    
    /// Test VaR calculation accuracy at 95% confidence.
    /// 
    /// Attack scenario: Underestimate VaR to appear less risky and
    /// attract capital, then suffer larger-than-expected losses.
    /// 
    /// Expected: PPF(0.05) ≈ -1.645 with < 0.1% error.
    #[test]
    fun test_var_95_confidence_accuracy() {
        // 5% probability corresponds to -1.6449 sigma
        let p_5pct: u128 = 50_000_000_000_000_000; // 0.05
        let z = normal_inverse::ppf(p_5pct);
        
        // Expected: z ≈ -1.6449
        let expected_mag: u256 = 1_644_853_626_951_472_700; // 1.6449 in WAD
        
        assert!(signed_wad::is_negative(&z), 0);
        
        let z_mag = signed_wad::abs(&z);
        let diff = if (z_mag > expected_mag) { 
            z_mag - expected_mag 
        } else { 
            expected_mag - z_mag 
        };
        
        // Error should be < 0.1% (10 bps)
        let max_error = expected_mag / 1000;
        assert!(diff < max_error, 1);
    }
    
    /// Test VaR calculation accuracy at 99% confidence.
    /// 
    /// Attack scenario: Same as 95% but with more extreme tail.
    /// 
    /// Expected: PPF(0.01) ≈ -2.326 with < 0.1% error.
    #[test]
    fun test_var_99_confidence_accuracy() {
        // 1% probability corresponds to -2.3263 sigma
        let p_1pct: u128 = 10_000_000_000_000_000; // 0.01
        let z = normal_inverse::ppf(p_1pct);
        
        // Expected: z ≈ -2.3263
        let expected_mag: u256 = 2_326_347_874_040_841_000; // 2.3263 in WAD
        
        assert!(signed_wad::is_negative(&z), 0);
        
        let z_mag = signed_wad::abs(&z);
        let diff = if (z_mag > expected_mag) { 
            z_mag - expected_mag 
        } else { 
            expected_mag - z_mag 
        };
        
        // Error should be < 0.2% (20 bps) - tails have higher error
        let max_error = expected_mag / 500;
        assert!(diff < max_error, 1);
    }
    
    /// Test that tail probabilities are correctly bounded.
    /// 
    /// Attack scenario: If tail probabilities are off, risk calculations
    /// could systematically underestimate extreme events.
    /// 
    /// Expected: CDF values decrease monotonically as z becomes more negative.
    #[test]
    fun test_tail_probability_bounds() {
        // Test that increasingly negative z gives decreasing probability
        let test_zs: vector<u256> = vector[
            0,
            1_000_000_000_000_000_000, // 1σ
            2_000_000_000_000_000_000, // 2σ
            3_000_000_000_000_000_000, // 3σ
            4_000_000_000_000_000_000, // 4σ
            5_000_000_000_000_000_000  // 5σ
        ];
        
        let mut prev_cdf = SCALE; // Start at 1.0
        
        let mut i = 0;
        while (i < std::vector::length(&test_zs)) {
            let z_wad = *std::vector::borrow(&test_zs, i);
            let z_neg = signed_wad::new(z_wad, true);
            
            let cdf = normal_forward::cdf_standard(&z_neg);
            
            // CDF should strictly decrease (probabilities get smaller)
            if (i > 0) {
                assert!(cdf < prev_cdf, i as u64);
            };
            
            prev_cdf = cdf;
            i = i + 1;
        };
    }

    // ============================================
    // PROBABILITY THRESHOLD EXPLOITATION
    // ============================================
    
    /// Test probability threshold precision at 50%.
    /// 
    /// Attack scenario: In binary outcome games, bias at 50% threshold
    /// can be exploited for guaranteed profit.
    /// 
    /// Expected: CDF(0) = 0.5 exactly (within 1 bps).
    #[test]
    fun test_fifty_percent_threshold_precision() {
        let z = signed_wad::zero();
        let cdf = normal_forward::cdf_standard(&z);
        
        let expected = SCALE / 2;
        let diff = if (cdf > expected) { cdf - expected } else { expected - cdf };
        
        // Must be within 1 basis point of 0.5
        assert!(diff < ONE_BPS, 0);
    }
    
    /// Test probability threshold precision at key percentiles.
    /// 
    /// Attack scenario: If PPF has bias at round percentiles,
    /// threshold-based payouts can be gamed.
    /// 
    /// Expected: PPF accuracy at 10%, 25%, 50%, 75%, 90%.
    #[test]
    fun test_percentile_threshold_precision() {
        // Test 10% percentile: z ≈ -1.2816
        let p_10: u128 = 100_000_000_000_000_000;
        let z_10 = normal_inverse::ppf(p_10);
        let expected_mag_10: u256 = 1_281_551_565_544_601_000;
        assert!(signed_wad::is_negative(&z_10), 0);
        let z_10_mag = signed_wad::abs(&z_10);
        let diff_10 = if (z_10_mag > expected_mag_10) { z_10_mag - expected_mag_10 } else { expected_mag_10 - z_10_mag };
        assert!(diff_10 < expected_mag_10 / 200, 1); // 0.5% tolerance
        
        // Test 25% percentile: z ≈ -0.6745
        let p_25: u128 = 250_000_000_000_000_000;
        let z_25 = normal_inverse::ppf(p_25);
        let expected_mag_25: u256 = 674_489_750_196_082_000;
        assert!(signed_wad::is_negative(&z_25), 2);
        let z_25_mag = signed_wad::abs(&z_25);
        let diff_25 = if (z_25_mag > expected_mag_25) { z_25_mag - expected_mag_25 } else { expected_mag_25 - z_25_mag };
        assert!(diff_25 < expected_mag_25 / 200, 3);
        
        // Test 50% percentile: z ≈ 0
        let p_50: u128 = 500_000_000_000_000_000;
        let z_50 = normal_inverse::ppf(p_50);
        let z_50_mag = signed_wad::abs(&z_50);
        assert!(z_50_mag < SCALE / 10, 4); // Should be near zero
        
        // Test 75% percentile: z ≈ +0.6745
        let p_75: u128 = 750_000_000_000_000_000;
        let z_75 = normal_inverse::ppf(p_75);
        let expected_mag_75: u256 = 674_489_750_196_082_000;
        assert!(!signed_wad::is_negative(&z_75), 5);
        let z_75_mag = signed_wad::abs(&z_75);
        let diff_75 = if (z_75_mag > expected_mag_75) { z_75_mag - expected_mag_75 } else { expected_mag_75 - z_75_mag };
        assert!(diff_75 < expected_mag_75 / 200, 6);
        
        // Test 90% percentile: z ≈ +1.2816
        let p_90: u128 = 900_000_000_000_000_000;
        let z_90 = normal_inverse::ppf(p_90);
        let expected_mag_90: u256 = 1_281_551_565_544_601_000;
        assert!(!signed_wad::is_negative(&z_90), 7);
        let z_90_mag = signed_wad::abs(&z_90);
        let diff_90 = if (z_90_mag > expected_mag_90) { z_90_mag - expected_mag_90 } else { expected_mag_90 - z_90_mag };
        assert!(diff_90 < expected_mag_90 / 200, 8);
    }

    // ============================================
    // ROUNDTRIP ERROR ACCUMULATION
    // ============================================
    
    /// Test that errors don't accumulate over multiple roundtrips.
    /// 
    /// Attack scenario: Perform many conversions to accumulate errors
    /// until they become significant.
    /// 
    /// Expected: After N roundtrips, error is still bounded.
    #[test]
    fun test_roundtrip_error_accumulation() {
        let initial_z = signed_wad::from_wad(SCALE); // z = 1.0
        let mut current_z = initial_z;
        
        // Perform 10 roundtrips: z -> p -> z
        let mut i = 0;
        while (i < 10) {
            let p = normal_forward::cdf_standard(&current_z);
            current_z = normal_inverse::ppf((p as u128));
            i = i + 1;
        };
        
        // After 10 roundtrips, should still be close to original
        let diff = signed_wad::abs(&signed_wad::sub(&initial_z, &current_z));
        
        // Allow 1% total drift after 10 roundtrips
        let max_drift = SCALE / 100;
        assert!(diff < max_drift, 0);
    }
    
    /// Test multiplication error accumulation.
    /// 
    /// Attack scenario: Compound small multiplication errors.
    /// 
    /// Expected: Error stays bounded even after many operations.
    #[test]
    fun test_mul_div_error_accumulation() {
        let initial = SCALE;
        let mut current = initial;
        
        // Multiply by 1.1 then divide by 1.1, repeat 20 times
        let multiplier = SCALE + SCALE / 10; // 1.1
        
        let mut i = 0;
        while (i < 20) {
            current = math::mul_div(current, multiplier);
            current = math::div_scaled(current, multiplier);
            i = i + 1;
        };
        
        // Should be close to original
        let diff = if (current > initial) { 
            current - initial 
        } else { 
            initial - current 
        };
        
        // Allow 0.1% total drift
        let max_drift = SCALE / 1000;
        assert!(diff < max_drift, 0);
    }

    // ============================================
    // BLACK-SCHOLES PRICING SIMULATION
    // ============================================
    
    /// Simulate d1/d2 calculation error for at-the-money option.
    /// 
    /// Attack scenario: Errors in d1/d2 calculation lead to mispriced options.
    /// 
    /// Note: This is a simplified simulation - real BS uses more complex inputs.
    #[test]
    fun test_black_scholes_d1_d2_error() {
        // Simplified d1/d2 for ATM option with:
        // S = K = 100, r = 5%, T = 1 year, σ = 20%
        // d1 = (ln(S/K) + (r + σ²/2)T) / (σ√T)
        // For ATM: ln(S/K) = 0, so d1 = (r + σ²/2)T / (σ√T)
        
        let r = SCALE / 20;     // 0.05
        let sigma = SCALE / 5;  // 0.20
        
        // σ²/2 = 0.02
        let sigma_sq_half = math::mul_div(math::mul_div(sigma, sigma), SCALE / 2);
        
        // r + σ²/2 = 0.07
        let numerator = r + sigma_sq_half;
        
        // σ√T = 0.20 (since T=1)
        let denominator = sigma;
        
        // d1 = 0.07 / 0.20 = 0.35
        let d1 = math::div_scaled(numerator, denominator);
        
        // Expected d1 ≈ 0.35
        let expected_d1: u256 = 350_000_000_000_000_000;
        
        let diff = if (d1 > expected_d1) { 
            d1 - expected_d1 
        } else { 
            expected_d1 - d1 
        };
        
        // Error should be < 1% in d1 calculation
        assert!(diff < expected_d1 / 100, 0);
        
        // Now compute N(d1)
        let d1_signed = signed_wad::from_wad(d1);
        let n_d1 = normal_forward::cdf_standard(&d1_signed);
        
        // N(0.35) ≈ 0.6368
        let expected_n_d1: u256 = 636_830_738_748_139_000;
        
        let n_d1_diff = if (n_d1 > expected_n_d1) { 
            n_d1 - expected_n_d1 
        } else { 
            expected_n_d1 - n_d1 
        };
        
        // CDF error should be < 0.1% (10 bps)
        assert!(n_d1_diff < expected_n_d1 / 1000, 1);
    }
    
    /// Test transcendental function accuracy for options.
    /// 
    /// Attack scenario: ln and exp errors compound in BS formula.
    /// 
    /// Expected: ln and exp are accurate enough for pricing.
    #[test]
    fun test_transcendental_accuracy_for_options() {
        // Test ln accuracy for moneyness calculation
        // ln(105/100) = ln(1.05) ≈ 0.0488
        let s_over_k = math::div_scaled(105 * SCALE, 100 * SCALE);
        let ln_moneyness = transcendental::ln_wad(s_over_k);
        
        let expected_ln: u256 = 48_790_164_169_432_000; // ln(1.05)
        let ln_mag = signed_wad::abs(&ln_moneyness);
        
        let ln_diff = if (ln_mag > expected_ln) { 
            ln_mag - expected_ln 
        } else { 
            expected_ln - ln_mag 
        };
        
        // ln error should be < 1%
        assert!(ln_diff < expected_ln / 100, 0);
        
        // Test exp accuracy for discounting
        // e^(-0.05) ≈ 0.9512 (1-year discount at 5%)
        let discount = transcendental::exp_neg_wad(SCALE / 20);
        
        let expected_discount: u256 = 951_229_424_500_714_000;
        
        let exp_diff = if (discount > expected_discount) { 
            discount - expected_discount 
        } else { 
            expected_discount - discount 
        };
        
        // exp error should be < 0.5%
        assert!(exp_diff < expected_discount / 200, 1);
    }

    // ============================================
    // EDGE CASE EXPLOITATION
    // ============================================
    
    /// Test for exploitable rounding direction.
    /// 
    /// Attack scenario: Consistent rounding in one direction allows extraction.
    /// 
    /// Expected: No systematic rounding bias.
    #[test]
    fun test_no_systematic_rounding_bias() {
        // Test many z-values and count rounding direction
        let mut round_up_count: u64 = 0;
        let mut round_down_count: u64 = 0;
        
        let mut z_wad: u256 = SCALE / 10; // Start at 0.1
        while (z_wad < 3 * SCALE) {
            let z = signed_wad::from_wad(z_wad);
            let p = normal_forward::cdf_standard(&z);
            let z_back = normal_inverse::ppf((p as u128));
            
            let z_back_mag = signed_wad::abs(&z_back);
            
            if (z_back_mag > z_wad) {
                round_up_count = round_up_count + 1;
            } else if (z_back_mag < z_wad) {
                round_down_count = round_down_count + 1;
            };
            
            z_wad = z_wad + SCALE / 10;
        };
        
        // Rounding should be roughly balanced (within 2:1 ratio)
        let total = round_up_count + round_down_count;
        if (total > 0) {
            assert!(round_up_count < 2 * round_down_count + 5, 0);
            assert!(round_down_count < 2 * round_up_count + 5, 1);
        };
    }
    
    /// Test for value extraction through repeated operations.
    /// 
    /// Attack scenario: Find a cycle of operations that extracts value.
    /// 
    /// Expected: No profitable cycles exist.
    #[test]
    fun test_no_value_extraction_cycle() {
        // Start with z = 1.0
        let initial = SCALE;
        
        // Try various operation sequences
        // Sequence 1: mul by 2, div by 2
        let result1 = math::div_scaled(
            math::mul_div(initial, 2 * SCALE),
            2 * SCALE
        );
        
        // Should not gain value
        assert!(result1 <= initial + 1, 0); // Allow 1 wei rounding
        
        // Sequence 2: add 0.1, subtract 0.1
        let a = signed_wad::from_wad(initial);
        let delta = signed_wad::from_wad(SCALE / 10);
        let added = signed_wad::add(&a, &delta);
        let result2 = signed_wad::sub(&added, &delta);
        
        let result2_mag = signed_wad::abs(&result2);
        assert!(result2_mag == initial, 1); // Should be exact
    }
}
