/// DeFi Exploit Scenario Test Suite for move-gaussian
/// 
/// This module tests attack vectors inspired by real-world DeFi exploits:
/// - Balancer ($128M) - Rounding direction attacks
/// - Euler Finance ($197M) - Flash loan + donation attacks  
/// - Compound/Aave - Oracle manipulation vectors
/// - Various protocols - Precision loss exploitation
/// 
/// # Attack Categories from Historical Exploits
/// 
/// 1. **Rounding Direction Attacks** (Balancer-style)
///    - Always rounds in attacker's favor
///    - Repeated small operations accumulate to significant theft
/// 
/// 2. **Flash Loan Attack Vectors**
///    - Atomic manipulation of probability calculations
///    - Price/probability oracle manipulation
/// 
/// 3. **Sandwich Attack Scenarios**
///    - Front-running probability-based transactions
///    - Back-running to extract value
/// 
/// 4. **Precision Loss Exploitation**
///    - Division before multiplication
///    - Truncation theft through repeated operations
/// 
/// 5. **First Depositor / Donation Attacks**
///    - Inflate share calculations via probability manipulation
/// 
/// 6. **Gas Griefing / DoS Vectors**
///    - Inputs that cause excessive computation
///    - Resource exhaustion attacks
/// 
/// # Threat Model
/// 
/// Adversary capabilities:
/// - Flash loans for infinite capital
/// - MEV capabilities (transaction ordering)
/// - Smart contract composability exploitation
/// - Full knowledge of implementation details
#[test_only]
#[allow(unused_use, unused_variable)]
module gaussian::defi_exploit_scenarios {
    use gaussian::normal_forward;
    use gaussian::normal_inverse;
    use gaussian::sampling;
    use gaussian::signed_wad;
    use gaussian::transcendental;
    use gaussian::math;
    use gaussian::coefficients;

    // === Constants ===
    
    const SCALE: u256 = 1_000_000_000_000_000_000;
    const SCALE_U128: u128 = 1_000_000_000_000_000_000;
    const MAX_Z: u256 = 6_000_000_000_000_000_000;
    const EPS: u128 = 100_000_000;
    const P_LOW: u128 = 20_000_000_000_000_000;
    const P_HIGH: u128 = 980_000_000_000_000_000;

    // ============================================
    // EXPLOIT 1: ROUNDING DIRECTION ATTACKS
    // (Inspired by Balancer $128M exploit)
    // ============================================
    
    /// Test: Rounding direction consistency in CDF calculations.
    /// 
    /// Attack scenario: If CDF(z) rounds differently for positive vs negative z,
    /// an attacker could profit by exploiting the asymmetry.
    /// 
    /// Real-world parallel: Balancer's rounding bug allowed attackers to extract
    /// value by repeatedly making trades that always rounded in their favor.
    #[test]
    fun test_rounding_direction_cdf_symmetry() {
        // Test that CDF(-z) + CDF(z) = 1 regardless of rounding direction
        let test_points: vector<u256> = vector[
            1,                         // Smallest value
            SCALE / 1000000,           // 0.000001
            SCALE / 1000,              // 0.001
            SCALE / 100,               // 0.01
            SCALE / 10,                // 0.1
            SCALE,                     // 1.0
            2 * SCALE,                 // 2.0
            3 * SCALE,                 // 3.0
            MAX_Z - 1                  // Near boundary
        ];
        
        let mut i = 0;
        while (i < std::vector::length(&test_points)) {
            let z_wad = *std::vector::borrow(&test_points, i);
            
            let z_pos = signed_wad::from_wad(z_wad);
            let z_neg = signed_wad::new(z_wad, true);
            
            let cdf_pos = normal_forward::cdf_standard(&z_pos);
            let cdf_neg = normal_forward::cdf_standard(&z_neg);
            
            // Sum should equal SCALE (1.0)
            let sum = cdf_pos + cdf_neg;
            
            // Check for rounding bias: difference from 1.0
            let bias = if (sum > SCALE) { sum - SCALE } else { SCALE - sum };
            
            // CRITICAL: Bias should be symmetric (not favor one direction)
            // If bias > 0, check it's not systematically positive or negative
            assert!(bias < SCALE / 10000, i as u64); // < 0.01% bias
            
            i = i + 1;
        };
    }
    
    /// Test: Repeated rounding exploitation.
    /// 
    /// Attack scenario: An attacker makes many small operations, each with
    /// rounding in their favor, accumulating significant theft.
    #[test]
    fun test_repeated_rounding_exploitation() {
        // Simulate sequential CDF → PPF → CDF operations
        // and check if error systematically drifts in one direction
        
        let initial_p: u128 = SCALE_U128 / 2; // Start at p = 0.5
        let mut p = initial_p;
        let num_iterations = 20;
        
        // Track drift magnitude and direction separately (Move has no signed ints)
        let mut total_drift_up: u128 = 0;
        let mut total_drift_down: u128 = 0;
        
        let mut i = 0;
        while (i < num_iterations) {
            // PPF: p → z
            let z = normal_inverse::ppf(p);
            
            // CDF: z → p'
            let p_new = normal_forward::cdf_standard(&z) as u128;
            
            // Track drift direction
            if (p_new > p) {
                total_drift_up = total_drift_up + (p_new - p);
            } else {
                total_drift_down = total_drift_down + (p - p_new);
            };
            
            p = p_new;
            i = i + 1;
        };
        
        // Net drift = |up - down|
        let net_drift = if (total_drift_up > total_drift_down) {
            total_drift_up - total_drift_down
        } else {
            total_drift_down - total_drift_up
        };
        
        // After 20 iterations, net drift should be < 0.1% of SCALE
        assert!(net_drift < SCALE_U128 / 1000, 0);
    }
    
    /// Test: Division vs multiplication ordering attack.
    /// 
    /// Attack scenario: Incorrect ordering (divide then multiply) loses precision.
    /// Attacker crafts inputs that maximize this loss in their favor.
    #[test]
    fun test_division_multiplication_order() {
        // Test that mul_div preserves precision better than separate ops
        let a: u256 = SCALE / 3; // 0.333...
        let b: u256 = 7 * SCALE; // 7.0
        
        // Method 1: (a * b) / SCALE (correct - multiply first)
        // This is what mul_div should do
        let result_correct = math::mul_div(a, b);
        
        // The result should be 7/3 ≈ 2.333...
        let expected = 2_333_333_333_333_333_333;
        let error = if (result_correct > expected) { 
            result_correct - expected 
        } else { 
            expected - result_correct 
        };
        
        // Error should be minimal (< 1 wei per unit)
        assert!(error < 10, 0);
    }

    // ============================================
    // EXPLOIT 2: FLASH LOAN ATTACK VECTORS
    // (Inspired by Euler Finance $197M exploit)
    // ============================================
    
    /// Test: Probability manipulation via extreme inputs.
    /// 
    /// Attack scenario: Attacker uses flash loan to temporarily create extreme
    /// market conditions, manipulates probability calculations, profits.
    /// 
    /// Real-world parallel: Euler Finance attack used flash loans to manipulate
    /// collateral ratios and trigger favorable liquidations.
    #[test]
    fun test_flash_loan_probability_manipulation() {
        // Scenario: Attacker tries to manipulate CDF output at critical thresholds
        
        // Critical threshold: z = -2 (≈2.28% probability, common liquidation trigger)
        let z_critical = signed_wad::new(2 * SCALE, true);
        let p_critical = normal_forward::cdf_standard(&z_critical);
        
        // Expected probability ≈ 0.0228
        let expected_p = 22_750_000_000_000_000; // 0.02275
        
        // Even with "manipulated" extreme inputs nearby, the math should be stable
        let z_slightly_less = signed_wad::new(2 * SCALE + SCALE / 100, true); // -2.01
        let z_slightly_more = signed_wad::new(2 * SCALE - SCALE / 100, true); // -1.99
        
        let p_less = normal_forward::cdf_standard(&z_slightly_less);
        let p_more = normal_forward::cdf_standard(&z_slightly_more);
        
        // Verify monotonicity (can't manipulate order)
        assert!(p_less < p_critical, 0);
        assert!(p_critical < p_more, 1);
        
        // Verify no jumps > 1% at critical threshold
        let jump_less = p_critical - p_less;
        let jump_more = p_more - p_critical;
        assert!(jump_less < SCALE / 100, 2);
        assert!(jump_more < SCALE / 100, 3);
    }
    
    /// Test: Donation attack on probability-weighted systems.
    /// 
    /// Attack scenario: First depositor inflates "shares" via probability manipulation.
    /// 
    /// Real-world parallel: ERC4626 vault inflation attacks, donation attacks.
    /// 
    /// Note: CDF at extreme z values is clamped to 0 or 1 by design, preventing
    /// exploits that try to get "infinite" or "zero" shares.
    #[test]
    fun test_donation_attack_probability_inflation() {
        // Scenario: Protocol uses CDF for share calculations
        // Attack: Manipulate z to get favorable share ratio
        
        // Legitimate user: z = 1 → CDF ≈ 0.8413
        let z_user = signed_wad::from_wad(SCALE);
        let shares_user = normal_forward::cdf_standard(&z_user);
        
        // Attacker tries to find z where CDF gives "infinite" shares
        // (CDF is bounded [0, 1], so this should fail)
        
        // Try extreme positive z
        let z_extreme = signed_wad::from_wad(MAX_Z);
        let shares_extreme = normal_forward::cdf_standard(&z_extreme);
        
        // CDF should still be ≤ 1.0
        assert!(shares_extreme <= SCALE, 0);
        
        // Ratio should not be exploitable
        // At z = -MAX_Z, CDF approaches 0 (clamped)
        let z_min = signed_wad::new(MAX_Z, true);
        let shares_min = normal_forward::cdf_standard(&z_min);
        
        // At z = -6, CDF is essentially 0 (by design - prevents underflow exploits)
        // This is CORRECT behavior - extreme tails are clamped
        // shares_min may be 0, which is expected
        assert!(shares_min <= SCALE / 1_000_000, 1); // Should be very small or 0
        
        // Key security property: ratio of max/min is bounded
        // An attacker cannot get infinite leverage via extreme z values
        assert!(shares_extreme <= SCALE, 2);
    }

    // ============================================
    // EXPLOIT 3: SANDWICH ATTACK SCENARIOS
    // (MEV exploitation of probability-based systems)
    // ============================================
    
    /// Test: Sandwich attack on PPF-based sampling.
    /// 
    /// Attack scenario: MEV searcher observes pending tx that will sample at
    /// probability p, sandwiches to manipulate outcome.
    /// 
    /// Note: With sui::random, this is mitigated by unpredictable randomness.
    /// This test verifies the math layer doesn't introduce new vulnerabilities.
    #[test]
    fun test_sandwich_attack_ppf_sampling() {
        // Scenario: User's tx will call PPF(0.5) expecting z ≈ 0
        // Attacker cannot manipulate PPF output (pure math)
        
        let victim_p: u128 = SCALE_U128 / 2;
        let victim_z = normal_inverse::ppf(victim_p);
        
        // Verify attacker can't change victim's z by calling PPF with different p
        let attacker_p: u128 = SCALE_U128 / 4;
        let attacker_z = normal_inverse::ppf(attacker_p);
        
        // Victim's z should still be ≈ 0
        let victim_z_mag = signed_wad::abs(&victim_z);
        assert!(victim_z_mag < SCALE / 10, 0); // |z| < 0.1
        
        // Verify no state pollution between calls
        let victim_z_repeat = normal_inverse::ppf(victim_p);
        let repeat_mag = signed_wad::abs(&victim_z_repeat);
        let orig_mag = signed_wad::abs(&victim_z);
        
        // Should get identical result
        assert!(repeat_mag == orig_mag, 1);
    }
    
    /// Test: Front-running probability threshold triggers.
    /// 
    /// Attack scenario: Protocol triggers liquidation when P(default) > 5%.
    /// Attacker front-runs to push user just over threshold.
    #[test]
    fun test_frontrun_probability_threshold() {
        // Threshold at P(Z < -1.645) = 5%
        let threshold_z_mag = 1_645_000_000_000_000_000; // |z| = 1.645
        let threshold_z = signed_wad::new(threshold_z_mag, true);
        let threshold_p = normal_forward::cdf_standard(&threshold_z);
        
        // Verify threshold is at expected ~5%
        let expected_threshold = 50_000_000_000_000_000; // 0.05
        let error = if (threshold_p > expected_threshold) {
            threshold_p - expected_threshold
        } else {
            expected_threshold - threshold_p
        };
        assert!(error < SCALE / 1000, 0); // Within 0.1%
        
        // Attacker tries to push z slightly past threshold
        let manipulated_z = signed_wad::new(threshold_z_mag + SCALE / 1000, true); // -1.646
        let manipulated_p = normal_forward::cdf_standard(&manipulated_z);
        
        // Verify the change is smooth (no cliff)
        let p_diff = if (threshold_p > manipulated_p) {
            threshold_p - manipulated_p
        } else {
            manipulated_p - threshold_p
        };
        
        // Small z change should produce small p change (no manipulation amplification)
        // Δp ≈ φ(z) * Δz ≈ 0.1 * 0.001 = 0.0001
        assert!(p_diff < SCALE / 1000, 1);
    }

    // ============================================
    // EXPLOIT 4: PRECISION LOSS EXPLOITATION
    // (Common DeFi vulnerability pattern)
    // ============================================
    
    /// Test: Small value precision loss extraction.
    /// 
    /// Attack scenario: Attacker makes many tiny operations, each losing 1 wei
    /// to the protocol, but protocol's loss accumulates to attacker's gain.
    #[test]
    fun test_small_value_precision_extraction() {
        // Test CDF at very small z values
        let tiny_values: vector<u256> = vector[
            1,
            10,
            100,
            1000,
            10000
        ];
        
        let mut i = 0;
        while (i < std::vector::length(&tiny_values)) {
            let z_wad = *std::vector::borrow(&tiny_values, i);
            
            let z = signed_wad::from_wad(z_wad);
            let cdf = normal_forward::cdf_standard(&z);
            
            // CDF should still be meaningful (not truncated to 0.5)
            // CDF(tiny) ≈ 0.5 + tiny * φ(0) ≈ 0.5 + tiny * 0.399
            let expected = SCALE / 2;
            let diff = if (cdf > expected) { cdf - expected } else { expected - cdf };
            
            // For very small z, CDF should be very close to 0.5
            // but not exactly 0.5 (that would indicate precision loss)
            if (z_wad > 100) {
                // For z > 100 wei, should see some difference from 0.5
                // (may not always be detectable for very small values)
            };
            
            // Key check: no overflow or underflow
            assert!(cdf > 0, i as u64);
            assert!(cdf < SCALE, (i + 100) as u64);
            
            i = i + 1;
        };
    }
    
    /// Test: Truncation theft via repeated operations.
    /// 
    /// Attack scenario: Each operation truncates ~0.5 wei. Over millions of
    /// operations, attacker extracts significant value.
    #[test]
    fun test_truncation_theft_accumulation() {
        // Perform many roundtrip operations and measure total loss
        let num_ops = 10;
        let start_value: u128 = SCALE_U128 / 2;
        let mut value = start_value;
        let mut total_loss: u128 = 0;
        
        let mut i = 0;
        while (i < num_ops) {
            let z = normal_inverse::ppf(value);
            let new_value = normal_forward::cdf_standard(&z) as u128;
            
            // Track loss (absolute difference)
            let loss = if (new_value > value) {
                new_value - value
            } else {
                value - new_value
            };
            total_loss = total_loss + loss;
            
            value = new_value;
            i = i + 1;
        };
        
        // Total loss over 10 operations should be bounded
        // Even if each op loses 1 wei, total should be < 1% of value
        assert!(total_loss < start_value / 100, 0);
    }

    // ============================================
    // EXPLOIT 5: ORACLE MANIPULATION
    // (Price/probability oracle attacks)
    // ============================================
    
    /// Test: Oracle manipulation resistance in probability calculations.
    /// 
    /// Attack scenario: Attacker manipulates input to oracle function to get
    /// favorable output for liquidation/pricing calculations.
    #[test]
    fun test_oracle_manipulation_resistance() {
        // Scenario: CDF is used as a "risk oracle"
        // Attacker tries to find inputs that produce unexpected outputs
        
        // Test boundary conditions that might confuse an oracle
        let boundary_tests: vector<u256> = vector[
            0,                         // Zero
            1,                         // Minimum non-zero
            SCALE - 1,                 // Just below 1.0
            SCALE,                     // Exactly 1.0
            SCALE + 1,                 // Just above 1.0
            MAX_Z - 1,                 // Just below max
            MAX_Z                      // At max
        ];
        
        let mut prev_cdf = 0u256;
        let mut i = 0;
        
        while (i < std::vector::length(&boundary_tests)) {
            let z_wad = *std::vector::borrow(&boundary_tests, i);
            let z = signed_wad::from_wad(z_wad);
            let cdf = normal_forward::cdf_standard(&z);
            
            // CDF must be in valid range
            assert!(cdf <= SCALE, i as u64);
            
            // CDF must be monotonically increasing
            assert!(cdf >= prev_cdf, (i + 100) as u64);
            
            prev_cdf = cdf;
            i = i + 1;
        };
    }
    
    /// Test: Input validation bypass attempts.
    /// 
    /// Attack scenario: Attacker tries to bypass input validation using
    /// edge case values (0, 1, max u128) to cause undefined behavior.
    /// 
    /// Note: After v0.9.0, ppf() strictly enforces domain (EPS, 1-EPS).
    /// Out-of-range values abort with EProbOutOfDomain.
    /// This test verifies that valid edge values still work.
    #[test]
    fun test_input_validation_bypass() {
        // Only test valid probabilities (within domain)
        let valid_edge_probs: vector<u128> = vector[
            EPS,                       // At minimum valid
            EPS * 2,                   // Just above EPS
            SCALE_U128 / 2,            // At 0.5
            SCALE_U128 - EPS * 2,      // Just below 1-EPS
            SCALE_U128 - EPS           // At maximum valid
        ];
        
        let mut i = 0;
        while (i < std::vector::length(&valid_edge_probs)) {
            let p = *std::vector::borrow(&valid_edge_probs, i);
            
            // PPF should handle all valid inputs without panic
            let z = normal_inverse::ppf(p);
            
            // Result should be bounded
            let z_mag = signed_wad::abs(&z);
            assert!(z_mag <= MAX_Z + SCALE, i as u64); // Allow some tolerance
            
            i = i + 1;
        };
    }

    // ============================================
    // EXPLOIT 6: GAS GRIEFING / DoS ATTACKS
    // ============================================
    
    /// Test: Expensive input detection.
    /// 
    /// Attack scenario: Attacker finds inputs that require maximum gas,
    /// uses them to grief other users or DoS the protocol.
    /// 
    /// Note: In Move/Sui, gas is metered differently, but computation cost matters.
    #[test]
    fun test_expensive_input_detection() {
        // Test inputs that might trigger expensive code paths
        
        // 1. Extreme tail probabilities (more Newton iterations?)
        let extreme_low_p = EPS;
        let z_low = normal_inverse::ppf(extreme_low_p);
        let _mag_low = signed_wad::abs(&z_low);
        
        // 2. Near-boundary z values (edge case handling)
        let near_boundary_z = signed_wad::from_wad(MAX_Z - 1);
        let _cdf_boundary = normal_forward::cdf_standard(&near_boundary_z);
        
        // 3. Many-digit precision values
        let precise_p: u128 = 123_456_789_012_345_678; // ~0.123...
        let _z_precise = normal_inverse::ppf(precise_p);
        
        // If we get here without timeout, no DoS vector found
        assert!(true, 0);
    }
    
    /// Test: Repeated expensive operations.
    /// 
    /// Attack scenario: Attacker calls expensive functions in a loop to exhaust gas.
    #[test]
    fun test_repeated_expensive_operations() {
        // Perform 5 full roundtrip operations at different probabilities
        let test_probs: vector<u128> = vector[
            100_000_000_000_000_000,   // 0.1
            300_000_000_000_000_000,   // 0.3
            500_000_000_000_000_000,   // 0.5
            700_000_000_000_000_000,   // 0.7
            900_000_000_000_000_000    // 0.9
        ];
        
        let mut i = 0;
        while (i < std::vector::length(&test_probs)) {
            let p = *std::vector::borrow(&test_probs, i);
            
            // Full roundtrip: PPF → CDF
            let z = normal_inverse::ppf(p);
            let _p_back = normal_forward::cdf_standard(&z);
            
            // Also compute PDF
            let _pdf = normal_forward::pdf_standard(&z);
            
            i = i + 1;
        };
        
        assert!(true, 0);
    }

    // ============================================
    // EXPLOIT 7: CROSS-PROTOCOL ARBITRAGE
    // (Multiple protocols using same math)
    // ============================================
    
    /// Test: Arbitrage between CDF and PPF implementations.
    /// 
    /// Attack scenario: If CDF and PPF have slight inconsistencies, an attacker
    /// can profit by arbitraging between protocols using each.
    #[test]
    fun test_cdf_ppf_arbitrage_opportunity() {
        // Dense sweep to find maximum CDF/PPF inconsistency
        let mut max_arbitrage: u128 = 0;
        
        let mut i: u64 = 1;
        while (i < 20) {
            // Test at various probability levels
            let p = (SCALE_U128 * (i as u128)) / 20;
            
            // Only test central region for speed
            if (p >= P_LOW && p <= P_HIGH) {
                let z = normal_inverse::ppf(p);
                let p_back = normal_forward::cdf_standard(&z) as u128;
                
                let diff = if (p_back > p) { p_back - p } else { p - p_back };
                if (diff > max_arbitrage) {
                    max_arbitrage = diff;
                };
            };
            
            i = i + 1;
        };
        
        // Maximum arbitrage opportunity should be < 0.05%
        // (too small to be profitable after gas costs)
        assert!(max_arbitrage < SCALE_U128 / 2000, 0);
    }
    
    /// Test: PDF integration vs CDF difference.
    /// 
    /// Attack scenario: PDF and CDF should be consistent (PDF = dCDF/dz).
    /// Inconsistency could be exploited in derivative pricing.
    #[test]
    fun test_pdf_cdf_integration_arbitrage() {
        // Numerical integration of PDF should approximately equal CDF
        let z_target: u256 = 2 * SCALE; // z = 2.0
        let num_steps: u64 = 20;
        let step = z_target / (num_steps as u256);
        
        // Riemann sum: ∫_{-∞}^{z} φ(t)dt ≈ Σ φ(z_i) * Δz
        // Start from z = -6 (CDF ≈ 0 there)
        let mut integral: u256 = 0;
        let mut z_current: u256 = 0;
        
        let mut i: u64 = 0;
        while (i < num_steps) {
            let z_signed = signed_wad::from_wad(z_current);
            let pdf = normal_forward::pdf_standard(&z_signed);
            
            // Add contribution: pdf * step / SCALE
            integral = integral + (pdf * step) / SCALE;
            z_current = z_current + step;
            i = i + 1;
        };
        
        // Compare to CDF difference
        let z_start = signed_wad::zero();
        let z_end = signed_wad::from_wad(z_target);
        let cdf_diff = normal_forward::cdf_standard(&z_end) - normal_forward::cdf_standard(&z_start);
        
        // They should be approximately equal (within 5% for this coarse integration)
        let error = if (integral > cdf_diff) { integral - cdf_diff } else { cdf_diff - integral };
        let tolerance = cdf_diff / 20; // 5%
        
        assert!(error < tolerance, 0);
    }

    // ============================================
    // EXPLOIT 8: STATE MANIPULATION ATTACKS
    // ============================================
    
    /// Test: Verify pure functions have no exploitable state.
    /// 
    /// Attack scenario: If functions have hidden state, attacker could
    /// manipulate it to get favorable outputs.
    #[test]
    fun test_no_hidden_state() {
        let p: u128 = 700_000_000_000_000_000; // 0.7
        
        // Call PPF multiple times - should always return same result
        let z1 = normal_inverse::ppf(p);
        let z2 = normal_inverse::ppf(p);
        let z3 = normal_inverse::ppf(p);
        
        let mag1 = signed_wad::abs(&z1);
        let mag2 = signed_wad::abs(&z2);
        let mag3 = signed_wad::abs(&z3);
        
        let neg1 = signed_wad::is_negative(&z1);
        let neg2 = signed_wad::is_negative(&z2);
        let neg3 = signed_wad::is_negative(&z3);
        
        // All should be identical
        assert!(mag1 == mag2 && mag2 == mag3, 0);
        assert!(neg1 == neg2 && neg2 == neg3, 1);
        
        // Same for CDF
        let z = signed_wad::from_wad(SCALE);
        let cdf1 = normal_forward::cdf_standard(&z);
        let cdf2 = normal_forward::cdf_standard(&z);
        let cdf3 = normal_forward::cdf_standard(&z);
        
        assert!(cdf1 == cdf2 && cdf2 == cdf3, 2);
    }
    
    /// Test: Coefficient immutability verification.
    /// 
    /// Attack scenario: If coefficients could be modified at runtime,
    /// attacker could change the math to their advantage.
    #[test]
    fun test_coefficient_immutability() {
        // Get coefficients multiple times - should always be same
        let (mag1_a, neg1_a) = coefficients::cdf_num_coeff(0);
        let (mag1_b, neg1_b) = coefficients::cdf_num_coeff(0);
        
        assert!(mag1_a == mag1_b, 0);
        assert!(neg1_a == neg1_b, 1);
        
        // Verify after calling other functions
        let _z = normal_inverse::ppf(500_000_000_000_000_000);
        
        let (mag2, neg2) = coefficients::cdf_num_coeff(0);
        assert!(mag1_a == mag2, 2);
        assert!(neg1_a == neg2, 3);
    }

    // ============================================
    // EXPLOIT 9: ECONOMIC ATTACK SCENARIOS
    // ============================================
    
    /// Test: Black-Scholes mispricing attack.
    /// 
    /// Attack scenario: Small errors in N(d1), N(d2) lead to option mispricing.
    /// Attacker arbitrages against protocols with different implementations.
    #[test]
    fun test_black_scholes_mispricing() {
        // Test N(d1) and N(d2) at critical Black-Scholes values
        // For ATM option with σ=0.2, T=1, r=0.05:
        // d1 ≈ 0.35, d2 ≈ 0.15
        
        let d1 = signed_wad::from_wad(350_000_000_000_000_000); // 0.35
        let d2 = signed_wad::from_wad(150_000_000_000_000_000); // 0.15
        
        let n_d1 = normal_forward::cdf_standard(&d1);
        let n_d2 = normal_forward::cdf_standard(&d2);
        
        // Expected values (from scipy.stats.norm.cdf)
        // N(0.35) ≈ 0.6368
        // N(0.15) ≈ 0.5596
        let expected_n_d1 = 636_800_000_000_000_000;
        let expected_n_d2 = 559_600_000_000_000_000;
        
        let error_d1 = if (n_d1 > expected_n_d1) { 
            n_d1 - expected_n_d1 
        } else { 
            expected_n_d1 - n_d1 
        };
        let error_d2 = if (n_d2 > expected_n_d2) { 
            n_d2 - expected_n_d2 
        } else { 
            expected_n_d2 - n_d2 
        };
        
        // Option pricing typically needs < 0.1% accuracy
        assert!(error_d1 < expected_n_d1 / 1000, 0);
        assert!(error_d2 < expected_n_d2 / 1000, 1);
    }
    
    /// Test: Liquidation threshold gaming.
    /// 
    /// Attack scenario: User positions themselves just above liquidation threshold.
    /// Small calculation error could incorrectly trigger or prevent liquidation.
    #[test]
    fun test_liquidation_threshold_gaming() {
        // Common liquidation threshold: 5% probability of default
        // This corresponds to z = -1.645
        let threshold_z = 1_645_000_000_000_000_000; // |z| = 1.645
        
        // User is at exactly threshold
        let z_at_threshold = signed_wad::new(threshold_z, true);
        let p_at_threshold = normal_forward::cdf_standard(&z_at_threshold);
        
        // User is 0.01% above threshold (should NOT be liquidated)
        let z_safe = signed_wad::new(threshold_z - SCALE / 10000, true);
        let p_safe = normal_forward::cdf_standard(&z_safe);
        
        // User is 0.01% below threshold (SHOULD be liquidated)
        let z_liquidate = signed_wad::new(threshold_z + SCALE / 10000, true);
        let p_liquidate = normal_forward::cdf_standard(&z_liquidate);
        
        // Verify ordering is correct (p_safe > p_at_threshold > p_liquidate)
        // Remember: more negative z = lower CDF
        assert!(p_safe > p_at_threshold, 0);
        assert!(p_at_threshold > p_liquidate, 1);
        
        // Differences should be small but measurable
        assert!(p_safe - p_at_threshold > 0, 2);
        assert!(p_at_threshold - p_liquidate > 0, 3);
    }

    // ============================================
    // EXPLOIT 10: COMPOSABILITY ATTACKS
    // ============================================
    
    /// Test: Composability with external math.
    /// 
    /// Attack scenario: Protocol A uses our CDF, Protocol B uses external sqrt.
    /// Attacker exploits differences in precision between protocols.
    #[test]
    fun test_composability_with_external_math() {
        // Test that our sqrt is consistent with what others might use
        let test_values: vector<u256> = vector[
            SCALE,          // sqrt(1) = 1
            2 * SCALE,      // sqrt(2) ≈ 1.414
            4 * SCALE,      // sqrt(4) = 2
            SCALE / 2       // sqrt(0.5) ≈ 0.707
        ];
        
        let expected_results: vector<u256> = vector[
            SCALE,
            1_414_213_562_373_095_000,
            2 * SCALE,
            707_106_781_186_547_000
        ];
        
        let mut i = 0;
        while (i < std::vector::length(&test_values)) {
            let val = *std::vector::borrow(&test_values, i);
            let expected = *std::vector::borrow(&expected_results, i);
            
            let actual = transcendental::sqrt_wad(val);
            let error = if (actual > expected) { actual - expected } else { expected - actual };
            
            // Error should be < 0.001%
            assert!(error < expected / 100000, i as u64);
            
            i = i + 1;
        };
    }
    
    /// Test: Multi-step financial calculation.
    /// 
    /// Attack scenario: Complex calculation accumulates errors across steps.
    /// Attacker exploits accumulated error at final step.
    #[test]
    fun test_multi_step_calculation_error() {
        // Simulate a multi-step financial calculation:
        // 1. Compute d1 for Black-Scholes
        // 2. Compute N(d1)
        // 3. Compute d2 = d1 - σ√T
        // 4. Compute N(d2)
        // 5. Compute call price
        
        // Parameters: S=K=100, σ=0.2, T=1, r=0
        let vol = SCALE / 5;  // 0.2
        let vol_sqrt_t = vol; // σ√T = 0.2 * 1 = 0.2
        
        // d1 = σ√T/2 = 0.1 (simplified for r=0, S=K)
        let d1 = SCALE / 10;
        
        // d2 = d1 - σ√T = 0.1 - 0.2 = -0.1
        let d2 = SCALE / 10; // magnitude
        let d2_neg = true;
        
        // Compute N(d1) and N(d2)
        let d1_signed = signed_wad::from_wad(d1);
        let d2_signed = signed_wad::new(d2, d2_neg);
        
        let n_d1 = normal_forward::cdf_standard(&d1_signed);
        let n_d2 = normal_forward::cdf_standard(&d2_signed);
        
        // Call price = S * N(d1) - K * N(d2) for r=0
        // With S=K=100: price = 100 * (N(d1) - N(d2))
        let price_factor = if (n_d1 > n_d2) { n_d1 - n_d2 } else { 0 };
        
        // For ATM option, price should be roughly 8% of spot (Black-Scholes)
        // N(0.1) ≈ 0.5398, N(-0.1) ≈ 0.4602
        // Price factor ≈ 0.0796
        let expected_factor = 80_000_000_000_000_000; // ~0.08
        let error = if (price_factor > expected_factor) {
            price_factor - expected_factor
        } else {
            expected_factor - price_factor
        };
        
        // Error should be < 5% of expected
        assert!(error < expected_factor / 20, 0);
    }
}
