# move-gaussian

On-chain Gaussian (normal) distribution library for Sui Move, using AAA-derived rational approximations.

## Status

✅ **Implemented & Tested** - All 117 tests passing

## Quick Start

```bash
# Build the package
sui move build

# Run all tests
sui move test

# Use in your project - add to Move.toml:
# [dependencies]
# gaussian = { git = "https://github.com/Evan-Kim2028/move-gaussian.git" }
```

## Overview

This library provides on-chain Gaussian distribution functions for Sui Move:

| Function | Description | API |
|----------|-------------|-----|
| **erf(x)** | Error function | `gaussian::erf::erf(x: u256): u256` |
| **erfc(x)** | Complementary error function (1 - erf) | `gaussian::erf::erfc(x: u256): u256` |
| **Φ(x)** | Standard normal CDF | `gaussian::erf::phi(x: u256): u256` |

All values use **WAD scaling** (multiply by 10^18). For example:
- Input `x = 1.5` → pass `1_500_000_000_000_000_000`
- Output `erf(1) ≈ 0.8427` → returns `842_700_792_956_151_261`

## Accuracy

| Metric | Value | 
|--------|-------|
| Max error vs scipy | 5.68e-11 |
| Target error | < 1e-7 |
| Improvement | **1,760x better than target** |
| Domain | x ∈ [0, 6] (covers 99.9999998% of distribution) |

## Architecture

```
┌─────────────────────────────────────────────────────────────────────┐
│                    PRODUCTION CYCLE                                  │
├─────────────────────────────────────────────────────────────────────┤
│                                                                      │
│  ┌─────────────┐    ┌─────────────┐    ┌─────────────┐              │
│  │   Python    │───▶│   Python    │───▶│    Move     │              │
│  │  AAA Algo   │    │  Pipeline   │    │   Package   │              │
│  └─────────────┘    └─────────────┘    └─────────────┘              │
│                                                                      │
│  1. Design rational   2. Scale to       3. Horner eval              │
│     approximation        fixed-point       on-chain                  │
│                                                                      │
└─────────────────────────────────────────────────────────────────────┘
```

### Why This Approach?

Blockchains have **no floating-point numbers**. To compute transcendental functions like `erf(x)`:

1. **AAA Algorithm** (Python) - Finds optimal rational approximation P(x)/Q(x)
2. **Fixed-Point Scaling** (Python) - Converts floats to WAD integers (1e18)
3. **Horner Evaluation** (Move) - Efficiently evaluates polynomials on-chain

The AAA algorithm automatically discovers the best polynomial degrees and coefficients, achieving 1000x better accuracy than hand-tuned approximations.

## Package Structure

```
packages/gaussian/
├── Move.toml                    # Package manifest
├── README.md                    # This file
├── sources/
│   ├── erf_coefficients.move   # 24 coefficients (P0-P11, Q0-Q11) - AUTO-GENERATED
│   ├── math.move               # Signed fixed-point arithmetic helpers
│   └── erf.move                # Horner evaluation, erf/erfc/phi API
├── tests/
│   └── erf_tests.move          # 100 generated test vectors - AUTO-GENERATED
└── scripts/                     # Python pipeline (see scripts/README.md)
    ├── src/                     # 7-step pipeline scripts
    ├── outputs/                 # Generated coefficients, test vectors
    └── docs/                    # Specification, verification reports
```

### Module Responsibilities

| Module | Purpose | Source |
|--------|---------|--------|
| `erf_coefficients` | Stores P(x) and Q(x) polynomial coefficients | Auto-generated by Python |
| `math` | Signed arithmetic (WAD has no negatives) | Hand-written |
| `erf` | Public API: `erf()`, `erfc()`, `phi()` | Hand-written |
| `erf_tests` | 100 test cases across domain [0, 6] | Auto-generated by Python |

## Development Workflow

### Regenerating Coefficients (Rare)

If you need to change the approximation (different function, higher accuracy):

```bash
cd scripts/

# 1. Install Python dependencies
pip install -r requirements.txt

# 2. Run the full pipeline
python run_all.py

# 3. Copy generated Move code to sources/
cp outputs/move_generated/erf_coefficients.move ../sources/
cp outputs/move_generated/erf_tests.move ../tests/

# 4. Rebuild and test
cd ..
sui move build
sui move test
```

### Normal Development

For most changes (API updates, bug fixes):

```bash
# Edit sources/*.move
sui move build
sui move test
```

## API Reference

### `gaussian::erf::erf(x: u256): u256`

Computes the error function erf(x).

```move
use gaussian::erf;

// erf(1.0) ≈ 0.8427
let x = 1_000_000_000_000_000_000; // 1.0 in WAD
let result = erf::erf(x);
// result ≈ 842_700_792_956_151_261
```

**Properties:**
- erf(0) = 0
- erf(∞) = 1
- erf(-x) = -erf(x) (symmetry - handle negative x in your code)

### `gaussian::erf::erfc(x: u256): u256`

Complementary error function: erfc(x) = 1 - erf(x).

```move
// erfc(0) = 1.0
let result = erf::erfc(0);
// result = 1_000_000_000_000_000_000
```

### `gaussian::erf::phi(x: u256): u256`

Standard normal CDF: Φ(x) = ½(1 + erf(x/√2)).

```move
// Φ(0) = 0.5
let result = erf::phi(0);
// result = 500_000_000_000_000_000
```

## Why Move?

Move/Sui solves a key challenge for Gaussian sampling: **native randomness**.

| Challenge | Solidity | Move |
|-----------|----------|------|
| Randomness source | Chainlink VRF ($$$, callbacks) | ✅ Native `sui::random` |
| Transcendental functions | Expensive approximations | Same (this library) |
| Fixed-point math | No native floats | Same (WAD scaling) |

## Technical Background

### The AAA Algorithm

The [AAA (Adaptive Antoulas-Anderson) algorithm](https://arxiv.org/abs/1612.00337) finds optimal rational approximations:

- **Input**: Sample points of target function (e.g., scipy.special.erf)
- **Output**: Rational function P(x)/Q(x) with minimal error
- **Key insight**: Barycentric form avoids Runge's phenomenon

Our (11,11) degree approximation achieves 5.68e-11 max error - comparable to double precision!

### Fixed-Point Arithmetic

Since Move uses unsigned integers, we track signs separately:

```move
// Represent -1.5 as (magnitude=1.5e18, is_negative=true)
public fun signed_add(
    a_mag: u256, a_neg: bool,
    b_mag: u256, b_neg: bool
): (u256, bool)
```

### Horner's Method

Evaluates polynomials efficiently:

```
P(x) = P0 + P1*x + P2*x² + ... + P11*x^11
     = P0 + x*(P1 + x*(P2 + ... + x*P11))
```

Only 11 multiplications instead of 66 (for degree 11).

## Future Work

- [ ] **PPF (Inverse CDF)** - Φ⁻¹(p) for Gaussian sampling
- [ ] **Integration with `sui::random`** - Full sampling API
- [ ] **Gas benchmarks** - Compare against other approaches
- [ ] **PDF** - Probability density function φ(x)

## References

- [AAA Algorithm Paper](https://arxiv.org/abs/1612.00337)
- [Primitive Finance SolStat](https://github.com/primitivefinance/solstat)
- [solgauss](https://github.com/cairoeth/solgauss)
- [Sui Random Module](https://docs.sui.io/references/framework/sui_sui/random)
- Abramowitz & Stegun, "Handbook of Mathematical Functions"

## License

MIT
