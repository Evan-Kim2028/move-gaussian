#!/usr/bin/env python3
"""
Unified Move export for Gaussian coefficients (CDF, PDF, PPF).

Consumes the scaled coefficient artifacts generated by the AAA pipeline and
produces a Move module (`gaussian::coefficients`) with production-ready values.

Inputs:
    outputs/scaled_coefficients.json       → Φ(z) coefficients (CDF)
    outputs/scaled_ppf_coefficients.json   → central & tail PPF coefficients
    outputs/pdf_aaa_results.json           → barycentric PDF approximation

Outputs:
    outputs/move_generated/coefficients.move
    outputs/move_generated/gaussian_coefficients_summary.json
"""

from __future__ import annotations

import json
from dataclasses import dataclass
from datetime import datetime, timezone
from decimal import Decimal, getcontext
from pathlib import Path
from typing import Dict, List, Sequence, Tuple

import numpy as np

try:
    from baryrat import BarycentricRational
except ImportError as exc:  # pragma: no cover - script guard
    raise SystemExit(
        "baryrat is required. Run `pip install baryrat` inside scripts/src`."
    ) from exc

getcontext().prec = 80
WAD = 10 ** 18
FNV_OFFSET_BASIS_128 = 0x6C62272E07BB014262B821756295C58D
FNV_PRIME_128 = 0x0000000001000000000000000000013B
MOD_2_128 = 1 << 128


@dataclass
class PolynomialCoefficients:
    p_magnitudes: List[int]
    p_signs: List[bool]
    q_magnitudes: List[int]
    q_signs: List[bool]
    numerator_degree: int
    denominator_degree: int


def scale_coefficients(p_coeffs: np.ndarray, q_coeffs: np.ndarray) -> PolynomialCoefficients:
    """Scale floating-point polynomial coefficients into WAD integers."""
    # Normalize denominator so q0 == 1
    if abs(q_coeffs[0]) < 1e-20:
        raise ValueError("Denominator constant term is ~0; cannot normalize")
    p_norm = p_coeffs / q_coeffs[0]
    q_norm = q_coeffs / q_coeffs[0]

    def to_wad(arr: Sequence[float]) -> Tuple[List[int], List[bool]]:
        mags: List[int] = []
        signs: List[bool] = []
        for value in arr:
            neg = value < 0
            mags.append(int(Decimal(str(abs(value) * WAD)).to_integral_value()))
            signs.append(bool(neg))
        return mags, signs

    p_mags, p_signs = to_wad(p_norm)
    q_mags, q_signs = to_wad(q_norm)
    return PolynomialCoefficients(
        p_mags,
        p_signs,
        q_mags,
        q_signs,
        len(p_mags) - 1,
        len(q_mags) - 1,
    )


def build_barycentric_rational(entry: dict) -> BarycentricRational:
    nodes = np.array(entry['nodes'])
    weights = np.array(entry['weights'])
    values = np.array(entry['values'])
    return BarycentricRational(nodes, values, weights)


def rational_to_polynomials(
    rational: BarycentricRational,
    degree: Tuple[int, int],
    domain: Tuple[float, float],
) -> Tuple[np.ndarray, np.ndarray]:
    """Convert barycentric rational to explicit numerator/denominator polynomials."""
    deg_num, deg_den = degree
    num_bary = rational.numerator()
    den_bary = rational.denominator()

    xs_num = np.linspace(domain[0], domain[1], deg_num + 1)
    xs_den = np.linspace(domain[0], domain[1], deg_den + 1)

    vander_num = np.vander(xs_num, deg_num + 1, increasing=True)
    vander_den = np.vander(xs_den, deg_den + 1, increasing=True)

    y_num = num_bary(xs_num)
    y_den = den_bary(xs_den)

    p = np.linalg.solve(vander_num, y_num)
    q = np.linalg.solve(vander_den, y_den)
    return p, q


def format_coeff_constants(prefix: str, mags: Sequence[int], signs: Sequence[bool]) -> str:
    lines = []
    for idx, (mag, neg) in enumerate(zip(mags, signs)):
        lines.append(f"    const {prefix}_{idx}_MAG: u128 = {mag};")
        lines.append(f"    const {prefix}_{idx}_NEG: bool = {'true' if neg else 'false'};")
    return "\n".join(lines)


def format_match_function(prefix: str, length: int, fn_name: str) -> str:
    body = [f"    public fun {fn_name}(i: u64): (u128, bool) {{"]
    last = length - 1
    indent = " " * 8
    if length == 1:
        body.append(f"{indent}({prefix}_0_MAG, {prefix}_0_NEG)")
    else:
        body.append(f"{indent}if (i == 0) {{")
        body.append(f"{indent}    ({prefix}_0_MAG, {prefix}_0_NEG)")
        for idx in range(1, last):
            body.append(f"{indent}}} else if (i == {idx}) {{")
            body.append(f"{indent}    ({prefix}_{idx}_MAG, {prefix}_{idx}_NEG)")
        body.append(f"{indent}}} else {{")
        body.append(f"{indent}    ({prefix}_{last}_MAG, {prefix}_{last}_NEG)")
        body.append(f"{indent}}}")
    body.append("    }")
    return "\n".join(body)


def fnv128_checksum(mags: Sequence[int], signs: Sequence[bool], label: str) -> int:
    """Compute 128-bit FNV-1a checksum over magnitude+sign pairs."""
    if len(mags) != len(signs):
        raise ValueError(f"{label}: magnitudes/signs length mismatch")

    acc = FNV_OFFSET_BASIS_128
    for mag, sign in zip(mags, signs):
        acc ^= int(mag) & (MOD_2_128 - 1)
        acc = (acc * FNV_PRIME_128) % MOD_2_128
        acc ^= int(bool(sign))
        acc = (acc * FNV_PRIME_128) % MOD_2_128
    acc ^= len(mags)
    acc = (acc * FNV_PRIME_128) % MOD_2_128
    return acc


def generate_move_module(
    cdf: dict,
    pdf: PolynomialCoefficients,
    ppf_central: dict,
    ppf_tail: dict,
    consts: dict,
    checksums: Dict[str, int],
) -> str:
    timestamp = datetime.now(timezone.utc).isoformat()
    parts = [
        f"/// Auto-generated Gaussian coefficient module.",
        f"/// Generated on {timestamp} UTC by 07_export_for_move_gaussian.py.",
        "module gaussian::coefficients {",
        "",
        f"    const SCALE: u128 = {WAD};",
        f"    const MAX_Z: u128 = {consts['max_z']};",
        f"    const EPS: u128 = {consts['eps']};",
        f"    const P_LOW: u128 = {consts['p_low']};",
        f"    const P_HIGH: u128 = {consts['p_high']};",
        "",
        f"    const FNV_OFFSET_BASIS_128: u256 = {FNV_OFFSET_BASIS_128};",
        f"    const FNV_PRIME_128: u256 = {FNV_PRIME_128};",
        "    const MOD_2_128: u256 = 340282366920938463463374607431768211456; // 2^128",
        "",
        "    public fun scale(): u128 { SCALE }",
        "    public fun max_z(): u128 { MAX_Z }",
        "    public fun eps(): u128 { EPS }",
        "    public fun p_low(): u128 { P_LOW }",
        "    public fun p_high(): u128 { P_HIGH }",
        "",
        f"    const CDF_NUM_LEN: u64 = {len(cdf['p_magnitudes'])};",
        f"    const CDF_DEN_LEN: u64 = {len(cdf['q_magnitudes'])};",
        "    public fun cdf_num_len(): u64 { CDF_NUM_LEN }",
        "    public fun cdf_den_len(): u64 { CDF_DEN_LEN }",
        format_coeff_constants('CDF_NUM', cdf['p_magnitudes'], cdf['p_signs']),
        "",
        format_coeff_constants('CDF_DEN', cdf['q_magnitudes'], cdf['q_signs']),
        "",
        format_match_function('CDF_NUM', len(cdf['p_magnitudes']), 'cdf_num_coeff'),
        "",
        format_match_function('CDF_DEN', len(cdf['q_magnitudes']), 'cdf_den_coeff'),
        "",
        f"    const CDF_CHECKSUM: u128 = {checksums['cdf']};",
        f"    const PDF_NUM_LEN: u64 = {len(pdf.p_magnitudes)};",
        f"    const PDF_DEN_LEN: u64 = {len(pdf.q_magnitudes)};",
        "    public fun pdf_num_len(): u64 { PDF_NUM_LEN }",
        "    public fun pdf_den_len(): u64 { PDF_DEN_LEN }",
        format_coeff_constants('PDF_NUM', pdf.p_magnitudes, pdf.p_signs),
        "",
        format_coeff_constants('PDF_DEN', pdf.q_magnitudes, pdf.q_signs),
        "",
        format_match_function('PDF_NUM', len(pdf.p_magnitudes), 'pdf_num_coeff'),
        "",
        format_match_function('PDF_DEN', len(pdf.q_magnitudes), 'pdf_den_coeff'),
        "",
        f"    const PDF_CHECKSUM: u128 = {checksums['pdf']};",
    ]

    parts.extend(
        [
            "",
            f"    const PPF_CENTRAL_NUM_LEN: u64 = {len(ppf_central['p_magnitudes'])};",
            f"    const PPF_CENTRAL_DEN_LEN: u64 = {len(ppf_central['q_magnitudes'])};",
            "    public fun ppf_central_num_len(): u64 { PPF_CENTRAL_NUM_LEN }",
            "    public fun ppf_central_den_len(): u64 { PPF_CENTRAL_DEN_LEN }",
            format_coeff_constants('PPF_CENTRAL_NUM', ppf_central['p_magnitudes'], ppf_central['p_signs']),
            "",
            format_coeff_constants('PPF_CENTRAL_DEN', ppf_central['q_magnitudes'], ppf_central['q_signs']),
            "",
            format_match_function('PPF_CENTRAL_NUM', len(ppf_central['p_magnitudes']), 'ppf_central_num_coeff'),
            "",
            format_match_function('PPF_CENTRAL_DEN', len(ppf_central['q_magnitudes']), 'ppf_central_den_coeff'),
            "",
            f"    const PPF_CENTRAL_CHECKSUM: u128 = {checksums['ppf_central']};",
            f"    const PPF_TAIL_NUM_LEN: u64 = {len(ppf_tail['p_magnitudes'])};",
            f"    const PPF_TAIL_DEN_LEN: u64 = {len(ppf_tail['q_magnitudes'])};",
            "    public fun ppf_tail_num_len(): u64 { PPF_TAIL_NUM_LEN }",
            "    public fun ppf_tail_den_len(): u64 { PPF_TAIL_DEN_LEN }",
            format_coeff_constants('PPF_TAIL_NUM', ppf_tail['p_magnitudes'], ppf_tail['p_signs']),
            "",
            format_coeff_constants('PPF_TAIL_DEN', ppf_tail['q_magnitudes'], ppf_tail['q_signs']),
            "",
            format_match_function('PPF_TAIL_NUM', len(ppf_tail['p_magnitudes']), 'ppf_tail_num_coeff'),
            "",
            format_match_function('PPF_TAIL_DEN', len(ppf_tail['q_magnitudes']), 'ppf_tail_den_coeff'),
            "",
            f"    const PPF_TAIL_CHECKSUM: u128 = {checksums['ppf_tail']};",
            "",
            "    fun fnv_update(acc: u256, value: u256): u256 {",
            "        let xored = acc ^ value;",
            "        (xored * FNV_PRIME_128) % MOD_2_128",
            "    }",
            "",
            "    fun checksum_cdf_num(): u128 {",
            "        let mut acc: u256 = FNV_OFFSET_BASIS_128;",
            "        let mut i: u64 = 0;",
            "        while (i < CDF_NUM_LEN) {",
            "            let (mag, neg) = cdf_num_coeff(i);",
            "            acc = fnv_update(acc, (mag as u256));",
            "            acc = fnv_update(acc, if (neg) { 1 } else { 0 });",
            "            i = i + 1;",
            "        };",
            "        acc = fnv_update(acc, (CDF_NUM_LEN as u256));",
            "        (acc % MOD_2_128) as u128",
            "    }",
            "",
            "    fun checksum_cdf_den(): u128 {",
            "        let mut acc: u256 = FNV_OFFSET_BASIS_128;",
            "        let mut i: u64 = 0;",
            "        while (i < CDF_DEN_LEN) {",
            "            let (mag, neg) = cdf_den_coeff(i);",
            "            acc = fnv_update(acc, (mag as u256));",
            "            acc = fnv_update(acc, if (neg) { 1 } else { 0 });",
            "            i = i + 1;",
            "        };",
            "        acc = fnv_update(acc, (CDF_DEN_LEN as u256));",
            "        (acc % MOD_2_128) as u128",
            "    }",
            "",
            "    fun checksum_pdf_num(): u128 {",
            "        let mut acc: u256 = FNV_OFFSET_BASIS_128;",
            "        let mut i: u64 = 0;",
            "        while (i < PDF_NUM_LEN) {",
            "            let (mag, neg) = pdf_num_coeff(i);",
            "            acc = fnv_update(acc, (mag as u256));",
            "            acc = fnv_update(acc, if (neg) { 1 } else { 0 });",
            "            i = i + 1;",
            "        };",
            "        acc = fnv_update(acc, (PDF_NUM_LEN as u256));",
            "        (acc % MOD_2_128) as u128",
            "    }",
            "",
            "    fun checksum_pdf_den(): u128 {",
            "        let mut acc: u256 = FNV_OFFSET_BASIS_128;",
            "        let mut i: u64 = 0;",
            "        while (i < PDF_DEN_LEN) {",
            "            let (mag, neg) = pdf_den_coeff(i);",
            "            acc = fnv_update(acc, (mag as u256));",
            "            acc = fnv_update(acc, if (neg) { 1 } else { 0 });",
            "            i = i + 1;",
            "        };",
            "        acc = fnv_update(acc, (PDF_DEN_LEN as u256));",
            "        (acc % MOD_2_128) as u128",
            "    }",
            "",
            "    fun checksum_ppf_central_num(): u128 {",
            "        let mut acc: u256 = FNV_OFFSET_BASIS_128;",
            "        let mut i: u64 = 0;",
            "        while (i < PPF_CENTRAL_NUM_LEN) {",
            "            let (mag, neg) = ppf_central_num_coeff(i);",
            "            acc = fnv_update(acc, (mag as u256));",
            "            acc = fnv_update(acc, if (neg) { 1 } else { 0 });",
            "            i = i + 1;",
            "        };",
            "        acc = fnv_update(acc, (PPF_CENTRAL_NUM_LEN as u256));",
            "        (acc % MOD_2_128) as u128",
            "    }",
            "",
            "    fun checksum_ppf_central_den(): u128 {",
            "        let mut acc: u256 = FNV_OFFSET_BASIS_128;",
            "        let mut i: u64 = 0;",
            "        while (i < PPF_CENTRAL_DEN_LEN) {",
            "            let (mag, neg) = ppf_central_den_coeff(i);",
            "            acc = fnv_update(acc, (mag as u256));",
            "            acc = fnv_update(acc, if (neg) { 1 } else { 0 });",
            "            i = i + 1;",
            "        };",
            "        acc = fnv_update(acc, (PPF_CENTRAL_DEN_LEN as u256));",
            "        (acc % MOD_2_128) as u128",
            "    }",
            "",
            "    fun checksum_ppf_tail_num(): u128 {",
            "        let mut acc: u256 = FNV_OFFSET_BASIS_128;",
            "        let mut i: u64 = 0;",
            "        while (i < PPF_TAIL_NUM_LEN) {",
            "            let (mag, neg) = ppf_tail_num_coeff(i);",
            "            acc = fnv_update(acc, (mag as u256));",
            "            acc = fnv_update(acc, if (neg) { 1 } else { 0 });",
            "            i = i + 1;",
            "        };",
            "        acc = fnv_update(acc, (PPF_TAIL_NUM_LEN as u256));",
            "        (acc % MOD_2_128) as u128",
            "    }",
            "",
            "    fun checksum_ppf_tail_den(): u128 {",
            "        let mut acc: u256 = FNV_OFFSET_BASIS_128;",
            "        let mut i: u64 = 0;",
            "        while (i < PPF_TAIL_DEN_LEN) {",
            "            let (mag, neg) = ppf_tail_den_coeff(i);",
            "            acc = fnv_update(acc, (mag as u256));",
            "            acc = fnv_update(acc, if (neg) { 1 } else { 0 });",
            "            i = i + 1;",
            "        };",
            "        acc = fnv_update(acc, (PPF_TAIL_DEN_LEN as u256));",
            "        (acc % MOD_2_128) as u128",
            "    }",
            "",
            "    #[test]",
            "    fun test_constants() {",
            "        assert!(scale() == SCALE, 0);",
            "        assert!(max_z() == MAX_Z, 1);",
            "        assert!(eps() == EPS, 2);",
            "        assert!(p_low() == P_LOW, 3);",
            "        assert!(p_high() == P_HIGH, 4);",
            "    }",
            "",
            "    #[test]",
            "    fun test_cdf_lengths() {",
            "        assert!(cdf_num_len() == CDF_NUM_LEN, 0);",
            "        assert!(cdf_den_len() == CDF_DEN_LEN, 1);",
            "    }",
            "",
            "    #[test]",
            "    fun test_ppf_lengths() {",
            "        assert!(ppf_central_num_len() == PPF_CENTRAL_NUM_LEN, 0);",
            "        assert!(ppf_tail_num_len() == PPF_TAIL_NUM_LEN, 1);",
            "    }",
            "",
            "    #[test]",
            "    fun test_checksums_match() {",
            "        let cdf = checksum_cdf_num() ^ checksum_cdf_den();",
            "        let pdf = checksum_pdf_num() ^ checksum_pdf_den();",
            "        let ppf_c = checksum_ppf_central_num() ^ checksum_ppf_central_den();",
            "        let ppf_t = checksum_ppf_tail_num() ^ checksum_ppf_tail_den();",
            "        assert!(cdf == CDF_CHECKSUM, 0);",
            "        assert!(pdf == PDF_CHECKSUM, 1);",
            "        assert!(ppf_c == PPF_CENTRAL_CHECKSUM, 2);",
            "        assert!(ppf_t == PPF_TAIL_CHECKSUM, 3);",
            "    }",
            "",
            "}",
        ]
    )

    return "\n".join(parts)


def export_gaussian_coefficients() -> None:
    scripts_dir = Path(__file__).resolve().parent.parent
    outputs = scripts_dir / 'outputs'
    artifacts_dir = scripts_dir.parent / 'artifacts' / 'move_generated'
    artifacts_dir.mkdir(parents=True, exist_ok=True)

    with open(outputs / 'scaled_coefficients.json', 'r') as f:
        scaled = json.load(f)
    with open(outputs / 'scaled_ppf_coefficients.json', 'r') as f:
        scaled_ppf = json.load(f)
    with open(outputs / 'pdf_aaa_results.json', 'r') as f:
        pdf_results = json.load(f)

    cdf_entry = scaled['phi']
    ppf_central = scaled_ppf['ppf_central']
    ppf_tail = scaled_ppf['ppf_tail']

    pdf_rational = build_barycentric_rational(pdf_results['pdf'])
    pdf_p, pdf_q = rational_to_polynomials(
        pdf_rational,
        tuple(pdf_results['pdf']['degree']),
        tuple(pdf_results['pdf']['domain']),
    )
    pdf_coeffs = scale_coefficients(pdf_p, pdf_q)

    consts = {
        'max_z': int(Decimal(str(6.0)) * WAD),
        'eps': int(Decimal(str(scaled_ppf['config']['eps'])) * WAD),
        'p_low': int(Decimal(str(scaled_ppf['config']['p_low'])) * WAD),
        'p_high': int(Decimal(str(scaled_ppf['config']['p_high'])) * WAD),
    }

    checksums = {
        'cdf': fnv128_checksum(cdf_entry['p_magnitudes'], cdf_entry['p_signs'], "cdf_num")
        ^ fnv128_checksum(cdf_entry['q_magnitudes'], cdf_entry['q_signs'], "cdf_den"),
        'pdf': fnv128_checksum(pdf_coeffs.p_magnitudes, pdf_coeffs.p_signs, "pdf_num")
        ^ fnv128_checksum(pdf_coeffs.q_magnitudes, pdf_coeffs.q_signs, "pdf_den"),
        'ppf_central': fnv128_checksum(ppf_central['p_magnitudes'], ppf_central['p_signs'], "ppf_central_num")
        ^ fnv128_checksum(ppf_central['q_magnitudes'], ppf_central['q_signs'], "ppf_central_den"),
        'ppf_tail': fnv128_checksum(ppf_tail['p_magnitudes'], ppf_tail['p_signs'], "ppf_tail_num")
        ^ fnv128_checksum(ppf_tail['q_magnitudes'], ppf_tail['q_signs'], "ppf_tail_den"),
    }

    move_code = generate_move_module(cdf_entry, pdf_coeffs, ppf_central, ppf_tail, consts, checksums)

    move_file = artifacts_dir / 'coefficients.move'
    move_file.write_text(move_code + "\n")

    summary = {
        'generated_at': datetime.now(timezone.utc).isoformat(),
        'inputs': {
            'scaled_coefficients': str(outputs / 'scaled_coefficients.json'),
            'scaled_ppf_coefficients': str(outputs / 'scaled_ppf_coefficients.json'),
            'pdf_aaa_results': str(outputs / 'pdf_aaa_results.json'),
        },
        'artifacts': str(artifacts_dir),
        'constants': consts,
        'checksums': {k: hex(v) for k, v in checksums.items()},
        'cdf': {
            'numerator_degree': cdf_entry['numerator_degree'],
            'denominator_degree': cdf_entry['denominator_degree'],
            'max_error': cdf_entry.get('original_max_error'),
        },
        'pdf': {
            'numerator_degree': pdf_coeffs.numerator_degree,
            'denominator_degree': pdf_coeffs.denominator_degree,
            'max_error': pdf_results['pdf']['max_error'],
        },
        'ppf_central': {
            'numerator_degree': ppf_central['numerator_degree'],
            'denominator_degree': ppf_central['denominator_degree'],
            'max_error': ppf_central['max_error'],
        },
        'ppf_tail': {
            'numerator_degree': ppf_tail['numerator_degree'],
            'denominator_degree': ppf_tail['denominator_degree'],
            'max_error': ppf_tail['max_error'],
        },
    }

    summary_file = artifacts_dir / 'gaussian_coefficients_summary.json'
    with open(summary_file, 'w') as f:
        json.dump(summary, f, indent=2)

    print(f"Move coefficients written to: {move_file}")
    print(f"Summary written to: {summary_file}")


def main() -> None:
    export_gaussian_coefficients()


if __name__ == "__main__":
    main()

