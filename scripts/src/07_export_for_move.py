#!/usr/bin/env python3
"""
Step 7: Export Coefficients and Tests for Move Implementation

Generates:
1. Move module with hardcoded coefficients
2. Move test module with test vectors
3. JSON test vectors for validation

Usage:
    python 07_export_for_move.py

Output:
    ../outputs/move_generated/erf_coefficients.move
    ../outputs/move_generated/erf_tests.move
    ../outputs/test_vectors.json
"""

import json
from datetime import datetime
from pathlib import Path
import importlib.util
import numpy as np
from scipy.special import erf as scipy_erf

# Load FixedPointErf for generating test vectors
spec = importlib.util.spec_from_file_location(
    "horner_python",
    Path(__file__).parent / "04_horner_python.py"
)
module = importlib.util.module_from_spec(spec)
spec.loader.exec_module(module)
FixedPointErf = module.FixedPointErf

WAD = 10**18


def generate_move_coefficients(coeffs: dict, func_name: str = "erf") -> str:
    """
    Generate Move module with coefficient constants.
    
    Args:
        coeffs: Dictionary with p_magnitudes, p_signs, q_magnitudes, q_signs
        func_name: Function name (erf, erfc, phi)
    
    Returns:
        Move source code as string
    """
    p_mags = coeffs['p_magnitudes']
    p_signs = coeffs['p_signs']
    q_mags = coeffs['q_magnitudes']
    q_signs = coeffs['q_signs']
    
    timestamp = datetime.now().isoformat()
    
    move_code = f"""// AUTO-GENERATED - DO NOT EDIT MANUALLY
// Generated by: scripts/src/07_export_for_move.py
// Timestamp: {timestamp}
// Function: {func_name}
// Max approximation error: {coeffs.get('original_max_error', 'N/A'):.2e}
// Domain: [0, 6]

module gaussian::{func_name}_coefficients {{
    
    /// Scale factor (WAD = 10^18)
    const SCALE: u256 = 1_000_000_000_000_000_000;
    
    /// Number of numerator coefficients
    const P_DEGREE: u64 = {len(p_mags) - 1};
    
    /// Number of denominator coefficients  
    const Q_DEGREE: u64 = {len(q_mags) - 1};
    
    // ========================================
    // Numerator P(x) coefficients
    // P(x) = P0 + P1*x + P2*x² + ... + P{len(p_mags)-1}*x^{len(p_mags)-1}
    // ========================================
"""
    
    for i, (mag, neg) in enumerate(zip(p_mags, p_signs)):
        sign_str = "true" if neg else "false"
        move_code += f"    const P{i}: u256 = {mag};\n"
        move_code += f"    const P{i}_NEG: bool = {sign_str};\n"
    
    move_code += f"""
    // ========================================
    // Denominator Q(x) coefficients
    // Q(x) = Q0 + Q1*x + Q2*x² + ... + Q{len(q_mags)-1}*x^{len(q_mags)-1}
    // ========================================
"""
    
    for i, (mag, neg) in enumerate(zip(q_mags, q_signs)):
        sign_str = "true" if neg else "false"
        move_code += f"    const Q{i}: u256 = {mag};\n"
        move_code += f"    const Q{i}_NEG: bool = {sign_str};\n"
    
    move_code += f"""
    // ========================================
    // Getter functions (for use by erf module)
    // ========================================
    
    public fun scale(): u256 {{ SCALE }}
    public fun p_degree(): u64 {{ P_DEGREE }}
    public fun q_degree(): u64 {{ Q_DEGREE }}
    
    /// Get numerator coefficient at index i
    public fun p_coeff(i: u64): (u256, bool) {{
"""
    
    # Generate match cases for P coefficients
    for i in range(len(p_mags)):
        if i == 0:
            move_code += f"        if (i == {i}) {{ (P{i}, P{i}_NEG) }}\n"
        elif i < len(p_mags) - 1:
            move_code += f"        else if (i == {i}) {{ (P{i}, P{i}_NEG) }}\n"
        else:
            move_code += f"        else {{ (P{i}, P{i}_NEG) }}\n"
    
    move_code += """    }
    
    /// Get denominator coefficient at index i
    public fun q_coeff(i: u64): (u256, bool) {
"""
    
    # Generate match cases for Q coefficients
    for i in range(len(q_mags)):
        if i == 0:
            move_code += f"        if (i == {i}) {{ (Q{i}, Q{i}_NEG) }}\n"
        elif i < len(q_mags) - 1:
            move_code += f"        else if (i == {i}) {{ (Q{i}, Q{i}_NEG) }}\n"
        else:
            move_code += f"        else {{ (Q{i}, Q{i}_NEG) }}\n"
    
    move_code += """    }
}
"""
    
    return move_code


def generate_test_vectors(evaluator: FixedPointErf, n_tests: int = 100) -> list:
    """
    Generate test vectors for Move tests.
    
    Args:
        evaluator: FixedPointErf instance
        n_tests: Number of test vectors
    
    Returns:
        List of (x_wad, expected_wad, tolerance_wad) tuples
    """
    test_vectors = []
    
    # Fixed test points (edge cases + regular grid)
    edge_cases = [0, 0.001, 0.01, 0.1, 0.5, 1.0, 1.5, 2.0, 2.5, 3.0, 4.0, 5.0, 5.5, 6.0]
    grid_points = np.linspace(0.05, 5.95, n_tests - len(edge_cases))
    
    all_points = list(edge_cases) + list(grid_points)
    
    for x in all_points:
        x_wad = int(x * WAD)
        expected_wad = evaluator.erf(x_wad)
        
        # Tolerance: allow 1e-7 error (100_000_000_000 in WAD terms)
        tolerance_wad = 100_000_000_000  # ~1e-7 in float
        
        test_vectors.append({
            'x': x,
            'x_wad': x_wad,
            'expected_wad': expected_wad,
            'expected_float': expected_wad / WAD,
            'scipy_reference': float(scipy_erf(x)),
            'tolerance_wad': tolerance_wad
        })
    
    return test_vectors


def generate_move_tests(test_vectors: list, func_name: str = "erf") -> str:
    """
    Generate Move test module with test vectors.
    
    Args:
        test_vectors: List of test vector dictionaries
        func_name: Function name
    
    Returns:
        Move test source code
    """
    timestamp = datetime.now().isoformat()
    
    move_code = f"""// AUTO-GENERATED - DO NOT EDIT MANUALLY
// Generated by: scripts/src/07_export_for_move.py
// Timestamp: {timestamp}
// Test vectors for {func_name}

#[test_only]
module gaussian::{func_name}_tests {{
    use gaussian::{func_name}::{func_name};
    
    /// Helper: absolute difference
    fun abs_diff(a: u256, b: u256): u256 {{
        if (a > b) {{ a - b }} else {{ b - a }}
    }}
    
"""
    
    # Generate individual tests
    for i, tv in enumerate(test_vectors):
        x_str = f"{tv['x']:.4f}".replace('.', '_')
        move_code += f"""    #[test]
    /// Test {func_name}({tv['x']}) ≈ {tv['expected_float']:.10f}
    fun test_{func_name}_{i}_{x_str}() {{
        let x = {tv['x_wad']}_u256;
        let expected = {tv['expected_wad']}_u256;
        let tolerance = {tv['tolerance_wad']}_u256;
        
        let result = {func_name}(x);
        let diff = abs_diff(result, expected);
        
        assert!(diff <= tolerance, {i});
    }}
    
"""
    
    move_code += "}\n"
    
    return move_code


def main():
    print("="*60)
    print("Step 7: Export for Move")
    print("="*60)
    
    # Load scaled coefficients
    input_dir = Path(__file__).parent.parent / 'outputs'
    with open(input_dir / 'scaled_coefficients.json', 'r') as f:
        all_coeffs = json.load(f)
    
    # Create output directory
    output_dir = input_dir / 'move_generated'
    output_dir.mkdir(exist_ok=True)
    
    # Generate for erf
    print("\n1. Generating erf coefficients module...")
    erf_coeffs = all_coeffs['erf']
    erf_move = generate_move_coefficients(erf_coeffs, 'erf')
    
    erf_file = output_dir / 'erf_coefficients.move'
    with open(erf_file, 'w') as f:
        f.write(erf_move)
    print(f"   Written: {erf_file}")
    
    # Generate test vectors
    print("\n2. Generating test vectors...")
    evaluator = FixedPointErf()
    test_vectors = generate_test_vectors(evaluator, n_tests=100)
    
    # Save as JSON
    tv_file = input_dir / 'test_vectors.json'
    with open(tv_file, 'w') as f:
        json.dump({
            'function': 'erf',
            'generated_at': datetime.now().isoformat(),
            'n_tests': len(test_vectors),
            'tolerance_description': '~1e-7 in float terms',
            'vectors': test_vectors
        }, f, indent=2)
    print(f"   Written: {tv_file}")
    
    # Generate Move tests
    print("\n3. Generating Move test module...")
    erf_tests_move = generate_move_tests(test_vectors, 'erf')
    
    tests_file = output_dir / 'erf_tests.move'
    with open(tests_file, 'w') as f:
        f.write(erf_tests_move)
    print(f"   Written: {tests_file}")
    
    # Summary
    print(f"\n{'='*60}")
    print("Summary")
    print("="*60)
    print(f"\nGenerated files:")
    print(f"  1. {erf_file}")
    print(f"  2. {tv_file}")
    print(f"  3. {tests_file}")
    
    print(f"\nCoefficient summary (erf):")
    print(f"  P(x) degree: {len(erf_coeffs['p_magnitudes']) - 1}")
    print(f"  Q(x) degree: {len(erf_coeffs['q_magnitudes']) - 1}")
    print(f"  Max error: {erf_coeffs.get('original_max_error', 'N/A'):.2e}")
    
    print(f"\nTest vectors: {len(test_vectors)}")
    
    print(f"\nNext steps:")
    print(f"  1. Copy Move files to sources/")
    print(f"  2. Implement Horner evaluation in Move")
    print(f"  3. Run Move tests: sui move test")


if __name__ == "__main__":
    main()
