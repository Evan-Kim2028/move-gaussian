#!/usr/bin/env python3
"""
Generate test vectors for transcendental functions (ln, exp, sqrt).

This script generates WAD-scaled reference values using Python's high-precision
math library for verification in Move tests.

Usage:
    python scripts/src/generate_transcendental_vectors.py
"""

import math
from decimal import Decimal, getcontext

# Set high precision for Decimal calculations
getcontext().prec = 50

WAD = 10**18


def to_wad(x: float) -> int:
    """Convert float to WAD-scaled integer."""
    return int(Decimal(str(x)) * WAD)


def from_wad(x: int) -> float:
    """Convert WAD-scaled integer to float."""
    return float(Decimal(x) / WAD)


def print_move_constant(name: str, value: int, comment: str = ""):
    """Print a Move constant definition."""
    if comment:
        print(f"    // {comment}")
    print(f"    const {name}: u256 = {value};")


def generate_ln_vectors():
    """Generate test vectors for ln_wad."""
    print("\n// === ln_wad Test Vectors ===")
    print("// Generated by scripts/src/generate_transcendental_vectors.py\n")
    
    test_cases = [
        (1.0, "ln(1) = 0"),
        (math.e, "ln(e) = 1"),
        (2.0, "ln(2)"),
        (0.5, "ln(0.5) = -ln(2)"),
        (10.0, "ln(10)"),
        (0.1, "ln(0.1) = -ln(10)"),
        (100.0, "ln(100) = 2*ln(10)"),
        (0.01, "ln(0.01) = -2*ln(10)"),
        (1.5, "ln(1.5)"),
        (0.001, "ln(0.001) - edge case small"),
        (1000.0, "ln(1000) - edge case large"),
    ]
    
    print("    // Test vectors: (input_wad, expected_magnitude, is_negative)")
    for x, comment in test_cases:
        ln_x = math.log(x)
        input_wad = to_wad(x)
        output_wad = to_wad(abs(ln_x))
        is_neg = ln_x < 0
        print(f"    // {comment}: ln({x}) = {ln_x:.15f}")
        print(f"    // Input: {input_wad}, Expected: {output_wad}, Negative: {is_neg}")
        print()


def generate_exp_vectors():
    """Generate test vectors for exp_wad."""
    print("\n// === exp_wad Test Vectors ===")
    print("// Generated by scripts/src/generate_transcendental_vectors.py\n")
    
    test_cases = [
        (0.0, "e^0 = 1"),
        (1.0, "e^1 = e"),
        (-1.0, "e^-1 = 1/e"),
        (2.0, "e^2"),
        (-2.0, "e^-2"),
        (0.5, "e^0.5 = sqrt(e)"),
        (-0.5, "e^-0.5 = 1/sqrt(e)"),
        (math.log(2), "e^ln(2) = 2"),
        (-math.log(2), "e^-ln(2) = 0.5"),
        (5.0, "e^5 - larger value"),
        (-5.0, "e^-5 - larger negative"),
        (10.0, "e^10 - near upper bound"),
        (-10.0, "e^-10 - near lower bound"),
    ]
    
    print("    // Test vectors: (input_wad, input_is_negative, expected_wad)")
    for x, comment in test_cases:
        exp_x = math.exp(x)
        input_wad = to_wad(abs(x))
        is_neg = x < 0
        output_wad = to_wad(exp_x)
        print(f"    // {comment}: e^{x} = {exp_x:.15f}")
        print(f"    // Input: {input_wad}, Negative: {is_neg}, Expected: {output_wad}")
        print()


def generate_sqrt_vectors():
    """Generate test vectors for sqrt_wad."""
    print("\n// === sqrt_wad Test Vectors ===")
    print("// Generated by scripts/src/generate_transcendental_vectors.py\n")
    
    test_cases = [
        (0.0, "sqrt(0) = 0"),
        (1.0, "sqrt(1) = 1"),
        (4.0, "sqrt(4) = 2"),
        (9.0, "sqrt(9) = 3"),
        (2.0, "sqrt(2)"),
        (0.5, "sqrt(0.5)"),
        (0.25, "sqrt(0.25) = 0.5"),
        (100.0, "sqrt(100) = 10"),
        (0.01, "sqrt(0.01) = 0.1"),
        (3.0, "sqrt(3)"),
        (math.e, "sqrt(e)"),
    ]
    
    print("    // Test vectors: (input_wad, expected_wad)")
    for x, comment in test_cases:
        sqrt_x = math.sqrt(x)
        input_wad = to_wad(x)
        output_wad = to_wad(sqrt_x)
        print(f"    // {comment}: sqrt({x}) = {sqrt_x:.15f}")
        print(f"    // Input: {input_wad}, Expected: {output_wad}")
        print()


def generate_roundtrip_vectors():
    """Generate roundtrip test vectors (exp(ln(x)) = x, ln(exp(x)) = x)."""
    print("\n// === Roundtrip Test Vectors ===")
    print("// These verify exp(ln(x)) ≈ x and ln(exp(x)) ≈ x\n")
    
    # exp(ln(x)) = x for various x > 0
    print("    // exp(ln(x)) = x tests")
    for x in [0.1, 0.5, 1.0, 2.0, 3.0, 5.0, 10.0, 100.0]:
        wad = to_wad(x)
        print(f"    // x = {x}: input_wad = {wad}")
    
    print()
    
    # ln(exp(x)) = x for various x
    print("    // ln(exp(x)) = x tests")
    for x in [-5.0, -2.0, -1.0, -0.5, 0.0, 0.5, 1.0, 2.0, 5.0]:
        wad = to_wad(abs(x))
        is_neg = x < 0
        print(f"    // x = {x}: input_wad = {wad}, is_negative = {is_neg}")


def generate_move_test_code():
    """Generate Move test code that can be copy-pasted."""
    print("\n" + "=" * 60)
    print("MOVE TEST CODE (copy-paste into transcendental.move)")
    print("=" * 60 + "\n")
    
    print("""
    #[test]
    fun test_ln_comprehensive() {
        // ln(10) ≈ 2.302585
        let result = ln_wad(10 * SCALE);
        let expected = 2_302_585_092_994_045_684u256;
        let mag = signed_wad::abs(&result);
        let diff = if (mag > expected) { mag - expected } else { expected - mag };
        assert!(diff < expected / 100, 0); // 1% tolerance
        assert!(!signed_wad::is_negative(&result), 1);
        
        // ln(0.1) ≈ -2.302585
        let result = ln_wad(SCALE / 10);
        let mag = signed_wad::abs(&result);
        let diff = if (mag > expected) { mag - expected } else { expected - mag };
        assert!(diff < expected / 100, 2);
        assert!(signed_wad::is_negative(&result), 3);
    }

    #[test]
    fun test_exp_comprehensive() {
        // e^2 ≈ 7.389056
        let x = signed_wad::from_wad(2 * SCALE);
        let result = exp_wad(&x);
        let expected = 7_389_056_098_930_650_227u256;
        let diff = if (result > expected) { result - expected } else { expected - result };
        assert!(diff < expected / 100, 0); // 1% tolerance
        
        // e^-2 ≈ 0.135335
        let x = signed_wad::new(2 * SCALE, true);
        let result = exp_wad(&x);
        let expected = 135_335_283_236_612_691u256;
        let diff = if (result > expected) { result - expected } else { expected - result };
        assert!(diff < expected / 100, 1);
    }

    #[test]
    fun test_sqrt_comprehensive() {
        // sqrt(0.5) ≈ 0.707107
        let result = sqrt_wad(SCALE / 2);
        let expected = 707_106_781_186_547_524u256;
        let diff = if (result > expected) { result - expected } else { expected - result };
        assert!(diff < expected / 10000, 0); // 0.01% tolerance
        
        // sqrt(100) = 10
        let result = sqrt_wad(100 * SCALE);
        let expected = 10 * SCALE;
        let diff = if (result > expected) { result - expected } else { expected - result };
        assert!(diff < SCALE / 1000000, 1);
    }

    #[test]
    fun test_ln_exp_inverse_property() {
        // ln(exp(x)) ≈ x for various x
        let test_values: vector<u256> = vector[
            SCALE / 2,      // 0.5
            SCALE,          // 1.0
            2 * SCALE,      // 2.0
            5 * SCALE,      // 5.0
        ];
        
        let mut i = 0;
        while (i < 4) {
            let x_wad = *std::vector::borrow(&test_values, i);
            let x = signed_wad::from_wad(x_wad);
            let exp_x = exp_wad(&x);
            let ln_exp_x = ln_wad(exp_x);
            let result_mag = signed_wad::abs(&ln_exp_x);
            
            // Should be close to original x
            let diff = if (result_mag > x_wad) { result_mag - x_wad } else { x_wad - result_mag };
            assert!(diff < x_wad / 50, i); // 2% tolerance for roundtrip
            
            i = i + 1;
        };
    }

    #[test]
    fun test_exp_ln_inverse_property() {
        // exp(ln(x)) ≈ x for various x > 0
        let test_values: vector<u256> = vector[
            SCALE / 10,     // 0.1
            SCALE / 2,      // 0.5
            SCALE,          // 1.0
            2 * SCALE,      // 2.0
            10 * SCALE,     // 10.0
        ];
        
        let mut i = 0;
        while (i < 5) {
            let x = *std::vector::borrow(&test_values, i);
            let ln_x = ln_wad(x);
            let exp_ln_x = exp_wad(&ln_x);
            
            // Should be close to original x
            let diff = if (exp_ln_x > x) { exp_ln_x - x } else { x - exp_ln_x };
            assert!(diff < x / 50, i); // 2% tolerance for roundtrip
            
            i = i + 1;
        };
    }

    #[test]
    fun test_sqrt_square_inverse() {
        // sqrt(x)^2 ≈ x
        let test_values: vector<u256> = vector[
            SCALE / 4,      // 0.25
            SCALE / 2,      // 0.5
            SCALE,          // 1.0
            2 * SCALE,      // 2.0
            10 * SCALE,     // 10.0
        ];
        
        let mut i = 0;
        while (i < 5) {
            let x = *std::vector::borrow(&test_values, i);
            let sqrt_x = sqrt_wad(x);
            // sqrt(x)^2 = sqrt_x * sqrt_x / SCALE
            let squared = math::mul_div(sqrt_x, sqrt_x);
            
            let diff = if (squared > x) { squared - x } else { x - squared };
            assert!(diff < x / 1000000, i); // Very tight tolerance for sqrt
            
            i = i + 1;
        };
    }
""")


def main():
    print("=" * 60)
    print("Transcendental Functions - Test Vector Generator")
    print("=" * 60)
    
    # Print key constants
    print("\n// === Key Constants ===")
    print_move_constant("LN_2", to_wad(math.log(2)), "ln(2)")
    print_move_constant("LN_10", to_wad(math.log(10)), "ln(10)")
    print_move_constant("E", to_wad(math.e), "e")
    print_move_constant("INV_E", to_wad(1/math.e), "1/e")
    print_move_constant("SQRT_2", to_wad(math.sqrt(2)), "sqrt(2)")
    print_move_constant("SQRT_E", to_wad(math.sqrt(math.e)), "sqrt(e)")
    
    generate_ln_vectors()
    generate_exp_vectors()
    generate_sqrt_vectors()
    generate_roundtrip_vectors()
    generate_move_test_code()
    
    print("\n" + "=" * 60)
    print("Generation complete!")
    print("=" * 60)


if __name__ == "__main__":
    main()
